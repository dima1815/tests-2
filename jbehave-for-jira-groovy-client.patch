Index: jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStoryLoader.groovy
===================================================================
--- jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStoryLoader.groovy	(date 1413359548000)
+++ jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/java/com/jbehaveforjira/groovyclient/GroovyStoryLoader.groovy	(revision )
@@ -1,0 +1,0 @@
Index: jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStepDocReporter.groovy
===================================================================
--- jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStepDocReporter.groovy	(date 1413359548000)
+++ jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/java/com/jbehaveforjira/groovyclient/GroovyStepDocReporter.groovy	(revision )
@@ -1,0 +1,0 @@
Index: jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStoryReporter.groovy
===================================================================
--- jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStoryReporter.groovy	(date 1413359548000)
+++ jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/java/com/jbehaveforjira/groovyclient/GroovyStoryReporter.groovy	(revision )
@@ -1,0 +1,0 @@
Index: jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStoryPathsFinder.groovy
===================================================================
--- jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyStoryPathsFinder.groovy	(date 1413359548000)
+++ jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/java/com/jbehaveforjira/groovyclient/GroovyStoryPathsFinder.groovy	(revision )
@@ -1,0 +1,0 @@
Index: jbehave-for-jira/jbehave-for-jira-groovy-client/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-groovy-client/pom.xml	(date 1413359548000)
+++ jbehave-for-jira/jbehave-for-jira-groovy-client/pom.xml	(revision )
@@ -7,16 +7,16 @@
     <artifactId>groovy-client</artifactId>
     <packaging>jar</packaging>
     <name>JBehave For Jira - Groovy Client</name>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.0.0-SNAPSHOT</version>
     <description>Groovy client for integrating with the 'JBehave for Jira - Jira Plugin' component</description>
     <url>http://www.jbehaveforjira.com</url>
     <build>
         <resources>
             <resource>
-                <directory>src/main/groovy</directory>
+                <directory>src/main/java</directory>
             </resource>
         </resources>
-        <sourceDirectory>src/main/groovy</sourceDirectory>
+        <!--<sourceDirectory>src/main/groovy</sourceDirectory>-->
         <plugins>
             <plugin>
                 <groupId>org.codehaus.gmavenplus</groupId>
@@ -30,13 +30,15 @@
                         <configuration>
                             <sources>
                                 <source>
-                                    <directory>${project.basedir}/src/main/groovy</directory>
+                                    <!--<directory>${project.basedir}/src/main/groovy</directory>-->
+                                    <directory>${project.basedir}/src/main/java</directory>
                                     <includes>
                                         <include>**/*.groovy</include>
                                     </includes>
                                 </source>
                             </sources>
                             <!--<outputDirectory>target/compiled-groovy</outputDirectory>-->
+                            <outputDirectory>target/classes</outputDirectory>
                         </configuration>
                     </execution>
                 </executions>
@@ -124,9 +126,9 @@
         </dependency>
         <dependency>
             <groupId>junit</groupId>
-            <artifactId>junit</artifactId>
+            <artifactId>junit-dep</artifactId>
             <version>4.10</version>
-            <scope>test</scope>
+            <!--<scope>test</scope>-->
         </dependency>
     </dependencies>
 </project>
\ No newline at end of file
Index: jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyTemplateStoryReporter.groovy
===================================================================
--- jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/groovy/com/jbehaveforjira/groovyclient/GroovyTemplateStoryReporter.groovy	(date 1413359548000)
+++ jbehave-for-jira/jbehave-for-jira-groovy-client/src/main/java/com/jbehaveforjira/groovyclient/GroovyTemplateStoryReporter.groovy	(revision )
@@ -8,6 +8,7 @@
 import org.apache.commons.lang.StringEscapeUtils
 import org.apache.commons.lang.StringUtils
 import org.apache.commons.lang.Validate
+import org.jbehave.core.annotations.AfterScenario
 import org.jbehave.core.configuration.Keywords
 import org.jbehave.core.model.*
 import org.jbehave.core.reporters.*
@@ -111,24 +112,23 @@
     }
 
     public void successful(String step) {
-        this.outputScenario.addStep(new OutputStep(step, "successful"));
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.passed));
     }
 
     public void ignorable(String step) {
-        this.outputScenario.addStep(new OutputStep(step, "ignorable"));
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.ignored));
     }
 
     public void pending(String step) {
-        this.outputScenario.addStep(new OutputStep(step, "pending"));
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.pending));
     }
 
     public void notPerformed(String step) {
-        this.outputScenario.addStep(new OutputStep(step, "notPerformed"));
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.not_performed));
     }
 
     public void failed(String step, Throwable storyFailure) {
-        this.failedStep = new OutputStep(step, "failed");
-        failedStep.failure = storyFailure;
+        this.failedStep = new FailedOutputStep(step, TestStatus.failed, storyFailure);
         this.outputScenario.addStep(failedStep);
     }
 
@@ -154,7 +154,6 @@
     }
 
     public void beforeExamples(List<String> steps, ExamplesTable table) {
-        this.outputScenario.examplesSteps = steps;
         this.outputScenario.examplesTable = table;
     }
 
@@ -183,8 +182,8 @@
                 List<OutputStep> scenarioSteps = outputScenario.steps;
                 boolean allSkipped = true;
                 for (OutputStep scenarioStep : scenarioSteps) {
-                    String stepOutcome = scenarioStep.outcome;
-                    if (!stepOutcome.equals("notPerformed")) {
+                    TestStatus stepOutcome = scenarioStep.outcome;
+                    if (stepOutcome != TestStatus.not_performed) {
                         allSkipped = false;
                         break;
                     }
@@ -195,8 +194,8 @@
                     // check if all ignored
                     boolean allIgnored = true;
                     for (OutputStep scenarioStep : scenarioSteps) {
-                        String stepOutcome = scenarioStep.outcome;
-                        if (!stepOutcome.equals("ignorable")) {
+                        TestStatus stepOutcome = scenarioStep.outcome;
+                        if (stepOutcome != TestStatus.ignored) {
                             allIgnored = false;
                             break;
                         }
@@ -584,6 +583,7 @@
     }
 
     public static class OutputLifecycle {
+
         private final Lifecycle lifecycle;
 
         public OutputLifecycle(Lifecycle lifecycle) {
@@ -591,29 +591,59 @@
         }
 
         public List<String> getBeforeSteps() {
-            return lifecycle.getBeforeSteps();
+
+            List<OutputStep> beforeSteps = new ArrayList<OutputStep>();
+            List<String> beforeStrSteps = lifecycle.getBeforeSteps();
+            if (beforeStrSteps != null) {
+                for (String beforeStrStep : beforeStrSteps) {
+                    OutputStep step = new OutputStep(beforeStrStep, TestStatus.passed);
+                    beforeSteps.add(step);
-        }
+                }
+            }
+            return beforeSteps;
+        }
 
         public List<String> getAfterSteps() {
-            return lifecycle.getAfterSteps();
+
+            List<OutputStep> afterSteps = new ArrayList<OutputStep>();
+
+            List<String> afterStrSteps = lifecycle.getAfterSteps();
+            lifecycle.getAfterSteps(AfterScenario.Outcome.FAILURE);
+            if (afterStrSteps != null) {
+                afterSteps = new ArrayList<OutputStep>();
+                for (String afterStrStep : afterStrSteps) {
+                    OutputStep step = new OutputStep(afterStrStep, TestStatus.passed);
+                    afterSteps.add(step);
-        }
+                }
+            }
 
-        public List<String> getAfterSteps(String outcome) {
-            // TODO there is no support yet for outcomes in After Lifecycle steps in JBehave 3.9
-            // we hack it here to always return for outcome - ANY
-            if ("ANY".equals(outcome)) {
-                return lifecycle.getAfterSteps();
-            } else {
-                return Collections.emptyList();
+            return afterSteps;
-            }
+        }
+
+        public List<String> getAfterSteps(String strOutcome) {
+
+            AfterScenario.Outcome outcome = AfterScenario.Outcome.valueOf(strOutcome);
+
+            List<String> strAfterSteps = lifecycle.getAfterSteps(outcome);
+            List<OutputStep> afterSteps = new ArrayList<OutputStep>(strAfterSteps.size());
+            for (String strAfterStep : strAfterSteps) {
+                OutputStep step = new OutputStep(strAfterStep, TestStatus.passed);
+                afterSteps.add(step);
-        }
+            }
 
+            return afterSteps;
+        }
+
         public List<String> getOutcomes() {
-            // TODO there is no support yet for outcomes in After Lifecycle steps in JBehave 3.9
-            // we hack it here to always return outcome - ANY
-            return Collections.singletonList("ANY");
+
+            AfterScenario.Outcome[] outcomes = AfterScenario.Outcome.values();
+            List<String> strOutcomes = new ArrayList<>(outcomes.length);
+            for (AfterScenario.Outcome outcome : outcomes ) {
+                strOutcomes.add(outcome.name());
-        }
+            }
+            return strOutcomes;
-    }
+        }
+    }
 
     public static class OutputScenario {
         private String title;
@@ -623,7 +653,7 @@
         private List<String> pendingMethods;
         private GivenStories givenStories;
         private String notAllowedBy;
-        private List<String> examplesSteps;
+
         private ExamplesTable examplesTable;
         private Map<String, String> currentExample;
         private List<Map<String, String>> examples = new ArrayList<Map<String, String>>();
@@ -678,10 +708,6 @@
             return notAllowedBy;
         }
 
-        public List<String> getExamplesSteps() {
-            return examplesSteps;
-        }
-
         public ExamplesTable getExamplesTable() {
             return examplesTable;
         }
@@ -689,6 +715,7 @@
         public List<Map<String, String>> getExamples() {
             return examples;
         }
+
     }
 
     public static class OutputRestart extends OutputStep {
@@ -699,26 +726,39 @@
 
     }
 
+    public static class FailedOutputStep extends OutputStep {
+
+        public FailedOutputStep(String step, TestStatus outcome, Throwable storyFailure) {
+            this.step = step;
+            this.outcome = outcome;
+            this.failure = storyFailure;
+            parse();
+        }
+    }
+
     public static class OutputStep {
 
-        private final String step;
+        protected String step;
 
-        private List<OutputStepToken> stepTokens;
+        protected List<OutputStepToken> stepTokens;
 
-        private final String outcome;
+        protected TestStatus outcome;
 
-        private Throwable failure;
+        protected Throwable failure;
 
-        private OutcomesTable outcomes;
+        protected OutcomesTable outcomes;
 
-        public OutputStep(String step, String outcome) {
+        protected OutputStep() {
+        }
 
+        public OutputStep(String step, TestStatus outcome) {
+
             this.step = step;
             this.outcome = outcome;
             parse();
         }
 
-        private void parse() {
+        protected void parse() {
 
             stepTokens = new ArrayList<>();
 
@@ -729,27 +769,28 @@
             stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.KEYWORD, keyword));
 
             String stepBody = step.substring(indexOfFirstSpace);
-            stepBody = remark(stepBody);
+            stepBody = remarkBody(stepBody);
 
             // find any parameter markers
-            Pattern paramPattern = Pattern.compile(
-                    "(.*)"
-                            + "(\\" + StepCreator.PARAMETER_VALUE_START + ")"
+            Pattern simpleParamPattern = Pattern.compile(
+                    "(.*?)"
+                            // have to use '+' quantifier as parameterized steps are marked with invisible markers two times
+                            + "((\\" + StepCreator.PARAMETER_VALUE_START + ")+)"
+                            + "(.*?)"
+                            + "((\\" + StepCreator.PARAMETER_VALUE_END + ")+)"
                             + "(.*)"
-                            + "(\\" + StepCreator.PARAMETER_VALUE_END + ")"
-                            + "(.*)"
                     , Pattern.DOTALL
             );
             Pattern tableParamPattern = Pattern.compile(
-                    "(.*)"
+                    "(.*?)"
                             + "(\\" + StepCreator.PARAMETER_TABLE_START + ")"
-                            + "(.*)"
+                            + "(.*?)"
                             + "(\\" + StepCreator.PARAMETER_TABLE_END + ")"
                             + "(.*)"
                     , Pattern.DOTALL
             );
             int pos = 0;
-            Matcher simpleParamMatcher = paramPattern.matcher(stepBody);
+            Matcher simpleParamMatcher = simpleParamPattern.matcher(stepBody);
             Matcher tableParamMatcher = tableParamPattern.matcher(stepBody);
             while (pos < stepBody.length()) {
 
@@ -759,9 +800,9 @@
                     if (beforeParam != null) {
                         stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, beforeParam));
                     }
-                    String paramValue = simpleParamMatcher.group(3);
+                    String paramValue = simpleParamMatcher.group(4);
                     stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.PARAMETER, paramValue));
-                    pos = simpleParamMatcher.end(4);
+                    pos = simpleParamMatcher.end(5);
                 } else if (tableParamMatcher.find(pos)) {
                     // tabular parameter
                     String beforeParam = tableParamMatcher.group(1);
@@ -792,7 +833,7 @@
         }
 
         public String getOutcome() {
-            return outcome;
+            return outcome.name();
         }
 
         public Throwable getFailure() {
@@ -801,18 +842,30 @@
 
         public String getFailureCause() {
             if (failure != null) {
-                return new StackTraceFormatter(true).stackTrace(failure);
+                return new StackTraceFormatter(false).stackTrace(failure);
             }
             return "";
         }
 
+        public String getUnderlyingErrorMsg() {
+            Throwable underlyingCause = failure;
+            while (underlyingCause.getCause() != null) {
+                underlyingCause = underlyingCause.getCause();
+            }
+            String message = underlyingCause.getMessage()
+            if (message == null && underlyingCause instanceof OutcomesTable.OutcomesFailed) {
+                message = "Outcomes Failed";
+            }
+            return message;
+        }
+
         public OutcomesTable getOutcomes() {
             return outcomes;
         }
 
         public String getOutcomesFailureCause() {
             if (outcomes.failureCause() != null) {
-                return new StackTraceFormatter(true).stackTrace(outcomes.failureCause());
+                return new StackTraceFormatter(false).stackTrace(outcomes.failureCause());
             }
             return "";
         }
@@ -825,42 +878,88 @@
             return text.contains(StepCreator.PARAMETER_TABLE_START) && text.contains(StepCreator.PARAMETER_TABLE_END);
         }
 
-        public static String remark(String text) {
+        public String remarkBody(String stepBody) {
 
             // custom work around for the fact that JBehave's step creator doesn't recognize custom types annotated
             // with AsParameters as tabular parameters
 
-            String[] lines = text.split(StepCreator.PARAMETER_VALUE_NEWLINE);
+            String[] lines = stepBody.split(StepCreator.PARAMETER_VALUE_NEWLINE);
 
             if (lines.length == 1) {
-                return text;
-            }
+                return stepBody;
+//                if (this.outcome == TestStatus.failed) {
+//                    // check if parsed error occurred
+//                    if (this.failure instanceof ExamplesTable.ParametersNotMappableToType
+//                            || (
+//                                this.failure instanceof UUIDExceptionWrapper
+//                                &&
+//                                ((UUIDExceptionWrapper)this.failure).getCause() instanceof ExamplesTable.ParametersNotMappableToType
+//                                )
+//                        ) {
+//                        // use case when we might have failed to parse the table parameter into custom type
+//                        // in this case we do still want to render them as table parameter in the story report
+//                        StringBuilder sb = new StringBuilder();
+//                        String[] bodyLines = stepBody.split("\n");
+//                        boolean inTable = false;
+//                        for (int i = 0; i < bodyLines.length; i++) {
+//                            String bodyLine = bodyLines[i];
+//                            if (!inTable && bodyLine.startsWith("|") && bodyLine.endsWith("|") && !bodyLine.startsWith("|--")) {
+//                                inTable = true;
+//                                sb.append(StepCreator.PARAMETER_TABLE_START);
+//                            }
+//                            if (inTable && (i == (bodyLines.length - 1) || !bodyLines[i + 1].startsWith("|"))) {
+//                                // this is last table line
+//                                int lastPipe = bodyLine.lastIndexOf("|");
+//                                sb.append(bodyLine.substring(0, lastPipe + 1));
+//                                sb.append(StepCreator.PARAMETER_TABLE_END);
+//                                sb.append(bodyLine.substring(lastPipe + 1));
+//                                inTable = false;
+//                            } else {
+//                                sb.append(bodyLine);
+//                            }
+//                            if (i != (bodyLines.length - 1)) {
+//                                sb.append("\n");
+//                            }
+//                        }
+//                        String result = sb.toString();
+//                        return result;
+//                    } else {
+//                        return stepBody;
+//                    }
+//                } else {
+//                    return stepBody;
+//                }
+            } else {
 
+//                boolean tableMarkedAlready = text.contains(StepCreator.PARAMETER_TABLE_START);
+
+                // use case for incorrectly marked tables
-            StringBuilder sb = new StringBuilder();
-            boolean inTable = false;
-            for (int i = 0; i < lines.length; i++) {
-                String line = lines[i];
-                if (!inTable && line.startsWith("|")) {
-                    inTable = true;
-                    sb.append(StepCreator.PARAMETER_TABLE_START);
-                }
-                if (inTable && (i == (lines.length - 1) || !lines[i + 1].startsWith("|"))) {
-                    // this is last table line
-                    int lastPipe = line.lastIndexOf("|");
-                    sb.append(line.substring(0, lastPipe + 1));
-                    sb.append(StepCreator.PARAMETER_TABLE_END);
-                    sb.append(line.substring(lastPipe + 1));
-                    inTable = false;
-                } else {
-                    sb.append(line);
-                }
-                if (i != (lines.length - 1)) {
-                    sb.append("\n");
-                }
-            }
+                StringBuilder sb = new StringBuilder();
+                boolean inTable = false;
+                for (int i = 0; i < lines.length; i++) {
+                    String line = lines[i];
+                    if (!inTable && line.startsWith("|")) {
+                        inTable = true;
+                        sb.append(StepCreator.PARAMETER_TABLE_START);
+                    }
+                    if (inTable && (i == (lines.length - 1) || !lines[i + 1].startsWith("|"))) {
+                        // this is last table line
+                        int lastPipe = line.lastIndexOf("|");
+                        sb.append(line.substring(0, lastPipe + 1));
+                        sb.append(StepCreator.PARAMETER_TABLE_END);
+                        sb.append(line.substring(lastPipe + 1));
+                        inTable = false;
+                    } else {
+                        sb.append(line);
+                    }
+                    if (i != (lines.length - 1)) {
+                        sb.append("\n");
+                    }
+                }
 
-            String result = sb.toString();
-            return result;
+                String result = sb.toString();
+                return result;
+            }
         }
 
 //        @SuppressWarnings("serial")
