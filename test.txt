Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/css/jbehave-edit.css
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/css/jbehave-edit.css	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/css/jbehave-edit.css	(revision )
@@ -1,47 +1,72 @@
-.cm-s-default .cm-meta-title {
+.cm-description-line {
+    color: dimgrey;
+}
+
+.cm-meta-title {
     color: #770088;
     font-weight: bold;
 }
 
-.cm-s-default .cm-meta-field {
+.cm-meta-field {
     color: #770088;
 }
 
-.cm-s-default .cm-narrative-title {
+.cm-narrative-title {
     color: #0000cc;
     font-weight: bold;
     font-size: 16px;
 }
 
-.cm-s-default .cm-narrative-field-keyword {
+.cm-narrative-field-keyword {
     color: #0000cc;
     font-weight: bold;
     font-size: 14px;
 }
 
-.cm-s-default .cm-narrative-field-value {
+.cm-narrative-field-value {
     color: #0000cc;
     font-size: 14px;
 }
 
-.cm-s-default .cm-scenario-keyword {
+.cm-scenario-keyword {
     color: green;
     font-weight: bold;
 }
 
-.cm-s-default .cm-scenario-title {
+.cm-scenario-title {
     color: green;
     /*font-weight: bold;*/
 }
 
-.cm-s-default .cm-step-keyword, .cm-s-default .cm-step-keyword-and {
+.cm-step-keyword {
     color: #aa5500;
     font-weight: bold;
 }
 
-.cm-s-default .cm-description-line {
-    color: dimgrey;
+.cm-step-keyword.cm-unmatched-step {
+    font-weight: normal;
+    font-style: italic;
 }
+
+.cm-step-body.cm-unmatched-step {
+    font-style: italic;
+    /*font-weight: bold;*/
+    /*font-weight: bold;*/
+    color: lightslategrey;
+}
+
+.cm-step-body.cm-step-parameter {
+    font-weight: bold;
+    color: purple;
+    /*color: chocolate;*/
+}
+
+/*.cm-unmatched-step {*/
+    /*font-style: italic;*/
+    /*font-weight: bold;*/
+    /*color: dimgrey;*/
+/*}*/
+
 
 /*.cm-s-default .cm-atom {color: #219;}*/
 /*.cm-s-default .cm-number {color: #164;}*/
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/ao/stepdoc/StepDoc.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/ao/stepdoc/StepDoc.java	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/ao/stepdoc/StepDoc.java	(revision )
@@ -28,4 +28,12 @@
     String getRegExpPattern();
 
     void setRegExpPattern(String regExpPattern);
+
+    String getGroupedRegExpPattern();
+
+    void setGroupedRegExpPattern(String groupedRegExpPattern);
+
+    String getParameterGroups();
+
+    void setParameterGroups(String parameterGroups);
 }
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/hint/jbehave-hint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/hint/jbehave-hint.js	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/hint/jbehave-hint.js	(revision )
@@ -22,40 +22,16 @@
     ];
 
     // fetch step hints
-    var stepDocs = undefined;
-    var fetchStepHints = function (projectKey) {
-
-        console.log("> jbehave-hint.fetchStepHints");
-        console.log("projectKey - " + projectKey);
-
-        var pathBase = "/jira/rest/story-res/1.0/";
-        var pathStepDocs = pathBase + "step-doc/for-project/" + projectKey;
-        console.log("pathStepDocs - " + pathStepDocs);
-
-        var successCallback = function (data, status, xhr) {
-            console.log("> jbehave-hint.fetchStepHints.successCallback");
-            console.log("status - " + status);
-            console.log("xhr.status - " + xhr.status);
-            console.log("data - " + data);
-
-            console.log("found step docs - " + JSON.stringify(data, null, "\t"));
-            stepDocs = data.stepDocs;
-
-            console.log("# jbehave-hint.fetchStepHints.successCallback");
-        };
-
-        AJS.$.ajax({
-            type: "GET",
-            url: pathStepDocs,
-            contentType: "text/plain; charset=utf-8",
-            success: successCallback,
-            dataType: "json"
+    var stepDocs = null;
+    AJS.$(function() {
+        var storyService = new StoryService();
+        var projectKey = new PageUtils().getProjectKey();
+//        console.log("projectKey - " + projectKey);
+        storyService.fetchStepDocs(projectKey, function (foundStepDocs) {
+            stepDocs = foundStepDocs;
         });
+    });
 
-        console.log("# jbehave-hint.fetchStepHints");
-    }
-    fetchStepHints("TESTING");
-
     CodeMirror.registerHelper("hint", "jbehave", function (editor, options) {
 
         console.log("########################## in autocomplete");
@@ -89,8 +65,6 @@
         }
 
         // hint on steps
-//        var stepHints = ["Given something", "Given something else"];
-        var stepHints = [];
         for (var k = 0; k < stepDocs.length; k++) {
             var stepHint = new Object();
             stepHint.text = stepDocs[k].startingWord + " " + stepDocs[k].pattern;
@@ -106,15 +80,7 @@
 
             };
 
-            stepHints.push(stepHint);
-        }
-
-
-        if (state.lastStepType == "Given") {
-            for (var i = 0; i < stepHints.length; i++) {
-                var stepHint = stepHints[i];
-                list.push(stepHint);
+            list.push(stepHint);
-            }
         }
 
         return {
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/comment/comment.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/comment/comment.js	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/comment/comment.js	(revision )
@@ -70,16 +70,10 @@
             } else {
                 for (var i = from.line; i < end; ++i) {
                     if (blankLines || nonWS.test(self.getLine(i))) {
-                        var replaceTo;
-                        if (options.commentFrom) {
-                            replaceTo = options.commentFrom;
-                        } else {
-                            replaceTo = 0;
+                        self.replaceRange(commentString + pad, Pos(i, 0));
-                        }
+                    }
-                        self.replaceRange(commentString + pad, Pos(i, 0), Pos(i, replaceTo));
-                    }
-                }
+                }
+            }
-            }
         });
     });
 
@@ -124,8 +118,6 @@
         // Try finding line comments
         var lineString = options.lineComment || mode.lineComment, lines = [];
         var pad = options.padding == null ? " " : options.padding, didSomething;
-        var uncommentFrom = options.uncommentFrom;
-        var uncommentTo = options.uncommentTo;
         lineComment: {
             if (!lineString) break lineComment;
             for (var i = start; i <= end; ++i) {
@@ -143,12 +135,6 @@
                     if (pos < 0) continue;
                     if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
                     didSomething = true;
-                    if (uncommentFrom) {
-                        pos = uncommentFrom;
-                    }
-                    if (uncommentTo) {
-                        endPos = uncommentTo;
-                    }
                     self.replaceRange("", Pos(i, pos), Pos(i, endPos));
                 }
             });
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/service/StepDocsServiceImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/service/StepDocsServiceImpl.java	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/service/StepDocsServiceImpl.java	(revision )
@@ -33,14 +33,69 @@
         }
 
         for (StepDocDTO stepDocDTO : stepDocs) {
+
+            // check if stepdoc has grouped pattern already set and if not calculate it and set it
+            if (stepDocDTO.getGroupedRegExpPattern() == null) {
+                setGroupedPatternOnStepDoc(stepDocDTO);
+            }
+
             StepDoc stepDoc = stepDocDao.create();
             stepDoc.setProjectKey(projectKey);
             StepDocDTOUtils.fromDTOToModel(stepDocDTO, stepDoc);
-            String regExpPattern = stepDocDTO.getRegExpPattern();
-            stepDoc.setRegExpPattern(regExpPattern);
             stepDoc.save();
         }
 
+    }
+
+    private void setGroupedPatternOnStepDoc(StepDocDTO stepDocDTO) {
+
+        String regExpPattern = stepDocDTO.getRegExpPattern();
+        StringBuilder groupedPatternBuilder = new StringBuilder();
+        List<Integer> parameterGroups = new ArrayList<Integer>();
+
+        int pos = 0;
+        int groupCount = 0;
+        int indexOfOpenBrace = regExpPattern.indexOf("(");
+        while(indexOfOpenBrace != -1) {
+
+            // we want to group everything before that opening brace
+            groupedPatternBuilder.append("(");
+            groupedPatternBuilder.append(regExpPattern.substring(pos, indexOfOpenBrace));
+            groupedPatternBuilder.append(")");
+            groupCount++;
+
+            int indexOfCloseBrace = regExpPattern.indexOf(")", indexOfOpenBrace);
+            Validate.isTrue(indexOfCloseBrace != -1, "Failed to find matching closing brace in pattern - " + regExpPattern);
+            pos = indexOfCloseBrace + 1;
+            groupedPatternBuilder.append(regExpPattern.substring(indexOfOpenBrace, pos));
+            groupCount++;
+            parameterGroups.add(groupCount);
+
+            if (pos >= regExpPattern.length()) {
+                // we have reached the end of the pattern
+                break;
+            } else {
+                indexOfOpenBrace = regExpPattern.indexOf("(", pos);
+                if (indexOfOpenBrace != -1) {
+                    // we simply iterate again
+                    continue;
+                } else {
+                    // there are no more parameter groups so we simply append any string into last group
+                    groupedPatternBuilder.append("(");
+                    groupedPatternBuilder.append(regExpPattern.substring(pos));
+                    groupedPatternBuilder.append(")");
+                    groupCount++;
+                }
+            }
+        }
+
+        String groupedPattern = groupedPatternBuilder.toString();
+        if (groupedPattern.isEmpty()) {
+            // reg exp pattern did not contain any groups
+            groupedPattern = "(" + regExpPattern + ")";
+        }
+        stepDocDTO.setGroupedRegExpPattern(groupedPattern);
+        stepDocDTO.setParameterGroups(parameterGroups);
     }
 
     @Override
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/atlassian-plugin.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/atlassian-plugin.xml	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/atlassian-plugin.xml	(revision )
@@ -10,7 +10,12 @@
     <!-- ==================================================================================================== -->
     <!--3rd party scripts-->
     <web-resource name="View Issue Page 3rd Party Resources" key="execspec-view-issue-page-3rd-party-resources">
+
         <context>jira.view.issue</context>
+        <!--these custom scripts need to be loaded first as jbehave-hint has dependency on story service-->
+        <resource type="download" name="PageUtils.js" location="/js/PageUtils.js"/>
+        <resource type="download" name="StoryService.js" location="/js/StoryService.js"/>
+
         <!--codemirror core-->
         <resource type="download" name="codemirror.js" location="/3rdparty/codemirror-4.3/lib/codemirror.js"/>
         <resource type="download" name="codemirror.css" location="/3rdparty/codemirror-4.3/lib/codemirror.css"/>
@@ -36,12 +41,10 @@
             <transformer key="soyTransformer"/>
         </transformation>
         <!--js-->
-        <resource type="download" name="PageUtils.js" location="/js/PageUtils.js"/>
         <resource type="download" name="StoryController.js" location="/js/StoryController.js"/>
         <resource type="download" name="StoryModel.js" location="/js/StoryModel.js"/>
         <resource type="download" name="StoryReportModel.js" location="/js/StoryReportModel.js"/>
         <resource type="download" name="AutoCompleteEntryModel.js" location="/js/AutoCompleteEntryModel.js"/>
-        <resource type="download" name="StoryService.js" location="/js/StoryService.js"/>
         <resource type="download" name="StoryView.js" location="/js/StoryView.js"/>
         <resource type="download" name="StoryEditHandler.js" location="/js/StoryEditHandler.js"/>
         <!--soy-->
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/mode/jbehave/jbehave.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/mode/jbehave/jbehave.js	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/mode/jbehave/jbehave.js	(revision )
@@ -30,13 +30,23 @@
         return {
             lineComment: "!--",
             tableLineComment: "|--",
+            blankLine: function (state) {
+//                console.log("### on blankLine");
+                state.lineNumber++;
+                if (state.inStep) {
+                    state.stepBodySoFar += "\n";
+                }
+            },
             startState: function () {
                 return {
-                    lineNumber: 0,
+                    lineNumber: -1,
+                    stepNumber: 0,
 
                     allowDescription: true,
+
                     allowMeta: true,
                     allowMetaField: false,
+
                     allowNarrative: true,
                     allowNarrativeInOrderTo: false,
                     allowNarrativeAsA: false,
@@ -49,7 +59,11 @@
                     inMultilineString: false,
                     inMultilineTable: false,
 
-                    lastStepType: null
+                    lastStepType: null,
+                    lastStepStartedAt: null,
+
+                    lastTokenType: null,
+                    stepBodySoFar: null
                 };
             },
             token: function (stream, state) {
@@ -61,12 +75,13 @@
                 }
 
                 // LINE COMMENT
-                if (stream.sol() && stream.match(/!--.*/)) {
-                    return "comment";
+                if (stream.sol() && (stream.match(/!--.*/) || stream.match(/\|--.*/))) {
+//                    state.lastTokenType =  "comment";
+                    return state.lastTokenType = "comment";
 
-                    // TABLE COMMENT
-                } else if (stream.sol() && stream.match(/\|--.*/)) {
-                    return "comment";
+//                    // TABLE COMMENT
+//                } else if (stream.sol() && stream.match(/\|--.*/)) {
+//                    return "comment";
 
                     // META title
                 } else if (state.allowMeta && stream.sol() && stream.match(/(Meta):/)) {
@@ -74,12 +89,12 @@
                     state.allowDescription = false;
                     state.allowMeta = false;
                     state.allowMetaField = true;
-                    return "meta-title";
+                    return state.lastTokenType = "meta-title line-number-line-" + state.lineNumber;
 
                     // META field
                 } else if (state.allowMetaField && stream.sol() && stream.match(/@.*/)) {
 
-                    return "meta-field"
+                    return state.lastTokenType = "meta-field";
 
                     // Narrative - title
                 } else if (state.allowNarrative && stream.sol() && stream.match(/Narrative:/)) {
@@ -92,7 +107,7 @@
 
                     state.allowScenario = true;
                     state.allowSteps = false;
-                    return "narrative-title";
+                    return state.lastTokenType = "narrative-title";
 
                     // Narrative - In order to - keyword
                 } else if (state.allowNarrativeInOrderTo && stream.sol() && stream.match(/(In order to )/)) {
@@ -101,7 +116,7 @@
                     state.allowNarrativeAsA = true;
                     state.inNarrativeField = true;
 
-                    return "narrative-field-keyword";
+                    return state.lastTokenType = "narrative-field-keyword";
 
                     // Narrative - As a - keyword
                 } else if (state.allowNarrativeAsA && stream.sol() && stream.match(/(As a )/)) {
@@ -110,7 +125,7 @@
                     state.allowNarrativeIWantTo = true;
                     state.inNarrativeField = true;
 
-                    return "narrative-field-keyword";
+                    return state.lastTokenType = "narrative-field-keyword";
 
                     // Narrative - I want to - keyword
                 } else if (state.allowNarrativeIWantTo && stream.sol() && stream.match(/(I want to )/)) {
@@ -118,52 +133,107 @@
                     state.allowNarrativeIWantTo = false;
                     state.inNarrativeField = true;
 
-                    return "narrative-field-keyword";
+                    return state.lastTokenType = "narrative-field-keyword";
 
                     // Narrative - field value
                 } else if (state.inNarrativeField && stream.match(/.*/)) {
 
-                    return "narrative-field-value";
+                    return state.lastTokenType = "narrative-field-value";
 
                     // SCENARIO keyword
                 } else if (state.allowScenario && stream.sol() && stream.match(/(Scenario):/)) {
                     state.allowSteps = true;
                     state.allowDescription = false;
                     state.inScenarioTitleLine = true;
-                    state.lastStepType = null;
+
+                    state.inStep = false;
                     state.allowAndStep = false;
-                    return "scenario-keyword";
+                    state.lastStepType = null;
+                    state.lastStepStartedAt = null;
 
+                    return state.lastTokenType = "scenario-keyword";
+
                     // SCENARIO title
-                } else if (state.inScenarioTitleLine && stream.match(/.*/)) {
-                    return "scenario-title";
+                } else if (state.inScenarioTitleLine && !stream.sol() && stream.match(/.*/)) {
+                    return state.lastTokenType = "scenario-title";
 
                     // GIVEN
                 } else if (state.allowSteps && stream.sol() && stream.match(/(Given )/)) {
                     state.lastStepType = "Given";
                     state.allowAndStep = true;
-                    return "step-keyword";
+                    state.inStep = true;
+                    state.stepNumber++;
+                    state.stepBodySoFar = "";
+                    state.lastStepStartedAt = state.lineNumber;
 
+                    state.inStepBody = false;
+                    state.stepBodyStartedAtCh = null;
+
+                    return state.lastTokenType = "step-keyword given-step";
+
                     // WHEN
                 } else if (state.allowSteps && stream.sol() && stream.match(/(When )/)) {
-                    state.lastStepType = "When";
+
+                    state.inStep = true;
                     state.allowAndStep = true;
-                    return "step-keyword";
+                    state.lastStepType = "When";
+                    state.stepNumber++;
+                    state.stepBodySoFar = "";
+                    state.lastStepStartedAt = state.lineNumber;
 
+                    state.inStepBody = false;
+                    state.stepBodyStartedAtCh = null;
+
+                    return state.lastTokenType = "step-keyword when-step";
+
                     // THEN
                 } else if (state.allowSteps && stream.sol() && stream.match(/(Then )/)) {
                     state.lastStepType = "Then";
                     state.allowAndStep = true;
-                    return "step-keyword";
+                    state.inStep = true;
+                    state.stepNumber++;
+                    state.stepBodySoFar = "";
+                    state.lastStepStartedAt = state.lineNumber;
 
+                    state.inStepBody = false;
+                    state.stepBodyStartedAtCh = null;
+
+                    return state.lastTokenType = "step-keyword then-step";
+
                     // AND
                 } else if (state.allowAndStep && stream.sol() && stream.match(/(And )/)) {
-                    return "step-keyword-and";
+                    state.inStep = true;
+                    state.stepNumber++;
+                    state.stepBodySoFar = "";
+                    state.lastStepStartedAt = state.lineNumber;
 
+                    state.inStepBody = false;
+                    state.stepBodyStartedAtCh = null;
+
+                    return state.lastTokenType = "step-keyword " + state.lastStepType + "-step";
+
                     // Description
                 } else if (stream.sol() && state.allowDescription && stream.match(/(.*)/)) {
 
-                    return "description-line";
+                    return state.lastTokenType = "description-line";
+
+                    // Step body
+                } else if (state.inStep && stream.match(/(.*)/, false)) {
+
+                    if (state.inStepBody == false) {
+                        // this is the first line of the step
+                        state.inStepBody = true;
+                        state.stepBodyStartedAtCh = stream.column();
+                    }
+                    stream.match(/(.*)/);
+
+                    state.stepBodySoFar += stream.current() + "\n";
+                    console.log("stepBodySoFar - " + state.stepBodySoFar);
+                    return state.lastTokenType = "step-body"
+//                        + "line-step-line"
+//                        + " line-step-number-" + state.stepNumber
+//                        + " line-step-line-number-" + state.lineNumber
+                        ;
 
                     // Fall through
                 } else {
Index: execspec/tests-2-master/example-projects/example-run-stories-as-paths/src/test/java/com/mycomp/execspec/JiraStepDocReporter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/example-projects/example-run-stories-as-paths/src/test/java/com/mycomp/execspec/JiraStepDocReporter.java	(date 1406459024000)
+++ execspec/tests-2-master/example-projects/example-run-stories-as-paths/src/test/java/com/mycomp/execspec/JiraStepDocReporter.java	(revision )
@@ -50,7 +50,7 @@
             StepMatcher stepMatcher = patternParser.parseStep(stepType, pattern);
             StepPattern stepPattern = stepMatcher.pattern();
             String regExpPattern = stepPattern.resolved();
-            StepDocDTO stepDocDTO = new StepDocDTO(stepType, startingWord, pattern, regExpPattern);
+            StepDocDTO stepDocDTO = new StepDocDTO(stepType, startingWord, pattern, regExpPattern, null, null);
             stepDocDTOs.add(stepDocDTO);
         }
 
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/dto/stepdoc/StepDocDTO.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/dto/stepdoc/StepDocDTO.java	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/dto/stepdoc/StepDocDTO.java	(revision )
@@ -5,6 +5,7 @@
 import javax.xml.bind.annotation.XmlAccessType;
 import javax.xml.bind.annotation.XmlAccessorType;
 import javax.xml.bind.annotation.XmlRootElement;
+import java.util.List;
 
 /**
  * Created by Dmytro on 4/23/2014.
@@ -17,15 +18,19 @@
     private String startingWord;
     private String pattern;
     private String regExpPattern;
+    private String groupedRegExpPattern;
+    private List<Integer> parameterGroups;
 
     protected StepDocDTO() {
     }
 
-    public StepDocDTO(StepType stepType, String startingWord, String pattern, String regExpPattern) {
+    public StepDocDTO(StepType stepType, String startingWord, String pattern, String regExpPattern, String groupedRegExpPattern, List<Integer> parameterGroups) {
         this.stepType = stepType;
         this.startingWord = startingWord;
         this.pattern = pattern;
         this.regExpPattern = regExpPattern;
+        this.groupedRegExpPattern = groupedRegExpPattern;
+        this.parameterGroups = parameterGroups;
     }
 
     public StepType getStepType() {
@@ -42,5 +47,33 @@
 
     public String getRegExpPattern() {
         return regExpPattern;
+    }
+
+    public String getGroupedRegExpPattern() {
+        return groupedRegExpPattern;
+    }
+
+    public List<Integer> getParameterGroups() {
+        return parameterGroups;
+    }
+
+    public void setGroupedRegExpPattern(String groupedRegExpPattern) {
+        this.groupedRegExpPattern = groupedRegExpPattern;
+    }
+
+    public void setParameterGroups(List<Integer> parameterGroups) {
+        this.parameterGroups = parameterGroups;
+    }
+
+    @Override
+    public String toString() {
+        return "StepDocDTO{" +
+                "stepType=" + stepType +
+                ", startingWord='" + startingWord + '\'' +
+                ", pattern='" + pattern + '\'' +
+                ", regExpPattern='" + regExpPattern + '\'' +
+                ", groupedRegExpPattern='" + groupedRegExpPattern + '\'' +
+                ", parameterGroups=" + parameterGroups +
+                '}';
     }
 }
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/js/StoryController.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/js/StoryController.js	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/js/StoryController.js	(revision )
@@ -20,9 +20,20 @@
     this.editor = null;
     this.currentStory = null;
     this.storyChanged = false;
+    this.stepDocs = null;
 
-    this.init  = function () {
+    this.init = function () {
 
+        storyController.debug("> init");
+
+        AJS.$(function () {
+            var storyService = new StoryService();
+            var projectKey = new PageUtils().getProjectKey();
+            storyService.fetchStepDocs(projectKey, function (foundStepDocs) {
+                storyController.stepDocs = foundStepDocs;
+            });
+        });
+
         var storyPanelContent = execspec.viewissuepage.showstory.renderStoryPanel();
         AJS.$("#story-panel").html(storyPanelContent);
 
@@ -32,11 +43,12 @@
         var editor = CodeMirror.fromTextArea(document.getElementById("storyTextArea"), {
             mode: "jbehave",
 //            lineComment: "!--",
+            lineNumbers: true,
             extraKeys: {
                 "Ctrl-Space": "autocomplete",
 
                 // commenting
-                "Ctrl-/": function(cm) {
+                "Ctrl-/": function (cm) {
 
 
                     console.log("commenting!");
@@ -51,11 +63,11 @@
                     var to = {line: endOfSelection.line, ch: endOfSelection.ch};
                     var options = new Object();
 
-                    if (curLine.substring(0,1) == "|") {
+                    if (curLine.substring(0, 1) == "|") {
                         options.lineComment = "|--";
-                        options.uncommentFrom = 1;
-                        options.uncommentTo = 3;
-                        options.commentFrom = 1;
+//                        options.uncommentFrom = 1;
+//                        options.uncommentTo = 3;
+//                        options.commentFrom = 1;
                     } else {
                         options.lineComment = "!--";
                     }
@@ -83,6 +95,8 @@
         editor.on("change", this.onEditorChangeHandler);
 
         this.loadStory();
+
+        storyController.debug("# init");
     }
 
     this.onEditorChangeHandler = function () {
@@ -92,10 +106,179 @@
             var saveCancelMsg = execspec.viewissuepage.showstory.renderSaveCancelMsg();
             storyController.showWarningMessage(saveCancelMsg);
         }
-
         storyController.storyChanged = true;
 
+        storyController.updateEditedStepStyle();
+
         storyController.debug("# onEditorChangeHandler");
+    }
+
+    this.updateEditedStepStyle = function () {
+
+        storyController.debug("> updateEditedStepStyle");
+
+        var editor = storyController.editor;
+        var cursor = editor.getCursor();
+        var line = cursor.line;
+        storyController.debug("line being edited - " + line);
+
+        var tokenAt = editor.getTokenAt(cursor, true);
+        storyController.debug("tokenAt.type - " + tokenAt.type);
+
+//        if (tokenAt.type == "step-body") {
+        if (tokenAt.state.inStepBody) {
+            storyController.debug("### modifying step ...");
+            var doc = editor.getDoc();
+            var stepBody = tokenAt.state.stepBodySoFar;
+            storyController.debug("stepBodySoFar - " + stepBody);
+            var inStepBody = true;
+            var nextLineNum = cursor.line;
+            var stepEndedAtLine = cursor.line;
+            if (cursor.ch != 0) {
+                // if we are in a step and also at the start of the line, i.e. case of multiline steps
+                // then we do not want to yet advance to the next line since we want to include the
+                // step body of this step line also
+                nextLineNum++;
+            } else {
+                stepEndedAtLine--;
+            }
+
+            var stepStartedAtLine = tokenAt.state.lastStepStartedAt;
+
+            while (inStepBody && nextLineNum < doc.lineCount()) {
+                var lineContent = editor.getLine(nextLineNum);
+                if (lineContent == undefined) {
+                    // we have reached the end of the story
+                    break;
+                } else if (lineContent.length == 0) {
+                    // empty line so simply move onto next line
+                    nextLineNum++;
+                    stepEndedAtLine++;
+                } else {
+                    var nextToken = editor.getTokenAt({line: nextLineNum, ch: 1}, true);
+                    if (nextToken.type != "step-body") {
+                        inStepBody = false;
+                    } else {
+                        stepBody = nextToken.state.stepBodySoFar;
+                        nextLineNum++;
+                        stepEndedAtLine++;
+                    }
+                }
+            }
+
+            storyController.debug("Modifying step body:\n" + stepBody);
+            stepBody = stepBody.replace(/\s+$/g, ''); // trim trailing whitespace
+            storyController.debug("Modifying step body after trimming:\n" + stepBody);
+            var lastStepType = tokenAt.state.lastStepType;
+            storyController.debug("lastStepType - " + lastStepType);
+
+            // check if step matches
+            var stepMatched = false;
+            var lastStepStartedAt = tokenAt.state.lastStepStartedAt;
+            var stepBodyStartedAtCh = tokenAt.state.stepBodyStartedAtCh;
+            var stepDocs = storyController.stepDocs;
+            var parameterGroupsInfos = [];
+
+            for (var i = 0; i < stepDocs.length; i++) {
+                var stepDoc = stepDocs[i];
+                if (stepDoc.startingWord == lastStepType) {
+                    // try to see if the step docs pattern matches step body
+                    var regExpStr = stepDoc.groupedRegExpPattern;
+                    // replace the (.*) with ([\s\S]*) for javascript version of dotall option
+                    regExpStr = regExpStr.replace("(.*)", "([\\s\\S]*)");
+                    // add start and end chars to match the string exactly
+                    regExpStr = "^" + regExpStr + "$";
+                    storyController.debug("Trying to match the step against pattern - " + regExpStr);
+                    var regExpPattern = new RegExp(regExpStr);
+                    var matched = regExpPattern.exec(stepBody);
+                    if (matched != null) {
+                        var step = lastStepType + " " + stepBody;
+                        storyController.debug("Step pattern - " + regExpStr + " matches current step");
+                        stepMatched = true;
+                        // obtain boundaries of any parameters
+                        var parameterGroups = stepDoc.parameterGroups;
+                        if (parameterGroups.length > 0) {
+                            var pos = stepBodyStartedAtCh;
+                            for (var j = 1; j < matched.length; j++) {
+                                var matchedGroup = matched[j];
+                                if (parameterGroups.indexOf(j) > -1) {
+                                    var pgi = new Object();
+                                    pgi.number = j;
+                                    pgi.text = matchedGroup;
+                                    pgi.startIndex = pos;
+                                    pgi.endIndex = pos + matchedGroup.length;
+
+                                    // work out start and end boundaries in terms of line and line position
+                                    // start position
+                                    var beforeParam = step.substring(0, pgi.startIndex);
+                                    var numOfLinesInBefore = beforeParam.split(/\n/).length;
+                                    var startAtLine = lastStepStartedAt + (numOfLinesInBefore - 1);
+                                    pgi.startAtLine = startAtLine;
+                                    var lastLineBreakPos = beforeParam.lastIndexOf("\n");
+                                    if (lastLineBreakPos == -1) {
+                                        lastLineBreakPos = 0;
+                                    }
+                                    pgi.startAtLineCh = pgi.startIndex - lastLineBreakPos;
+                                    // end position
+                                    var includingParam = step.substring(0, (pgi.startIndex + matchedGroup.length));
+                                    var numOfLinesInIncludingParam = includingParam.split(/\n/).length;
+                                    var endAtLine = lastStepStartedAt + (numOfLinesInIncludingParam - 1);
+                                    pgi.endAtLine = endAtLine;
+                                    lastLineBreakPos = includingParam.lastIndexOf("\n");
+                                    if (lastLineBreakPos == -1) {
+                                        lastLineBreakPos = 0;
+                                    }
+                                    pgi.endAtLineCh = pgi.endIndex - lastLineBreakPos;
+
+                                    parameterGroupsInfos.push(pgi);
+                                }
+                                pos += matchedGroup.length;
+                            }
+                        }
+                        break;
+                    }
+                }
+            }
+
+            var from = {line: stepStartedAtLine, ch: 0};
+            var to = {line: stepEndedAtLine, ch: null};
+            var options = new Object();
+
+            var marksBefore = doc.findMarks(from, to);
+
+            if (marksBefore.length > 0) {
+                // always remove any existing marks, so that we include newly edited text in the marked range
+                for (var m = 0; m < marksBefore.length; m++) {
+                    marksBefore[m].clear();
+                }
+            }
+
+            if (stepMatched) {
+                options.className = "cm-matched-step";
+            } else {
+                options.className = "cm-unmatched-step";
+            }
+            doc.markText(from, to, options);
+
+            var marksAfter = doc.findMarks(from, to);
+
+            // mark parameter boundaries
+            if (parameterGroupsInfos.length > 0) {
+                for (var k = 0; k < parameterGroupsInfos.length; k++) {
+                    var pgi = parameterGroupsInfos[k];
+                    var startLine = pgi.startAtLine;
+                    var startCh = pgi.startAtLineCh;
+                    var paramStart = {line: startLine, ch: startCh};
+                    var endLine = pgi.endAtLine;
+                    var endCh = pgi.endAtLineCh;
+                    var paramEnd = {line: endLine, ch: endCh};
+                    options.className = "cm-step-parameter";
+                    doc.markText(paramStart, paramEnd, options);
+                }
+            }
+        }
+
+        storyController.debug("# updateEditedStepStyle");
     }
 
     this.showWarningMessage = function (saveCancelMsg) {
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/js/StoryService.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/js/StoryService.js	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/resources/js/StoryService.js	(revision )
@@ -1,6 +1,6 @@
 function StoryService() {
 
-    this.debugOn = false;
+    this.debugOn = true;
 
     var pathBase = "/jira/rest/story-res/1.0/";
 
@@ -22,7 +22,6 @@
         }
     }
 
-
     this.init = function () {
 
         storyService.debug("> init");
@@ -31,11 +30,6 @@
         storyService.debug("# init");
     }
 
-
-    this.test = function () {
-        console.log("test function called in storyService");
-    }
-
     this.saveOrUpdateStory = function (storyPayload, callBack) {
 
         storyService.debug("> saveOrUpdateStory");
@@ -210,5 +204,38 @@
         storyService.debug("# StoryService.autoComplete");
     }
 
+    this.fetchStepDocs = function (projectKey, callback) {
+
+        this.debug("> fetchStepDocs");
+        this.debug("projectKey - " + projectKey);
+
+        var pathBase = "/jira/rest/story-res/1.0/";
+        var pathStepDocs = pathBase + "step-doc/for-project/" + projectKey;
+        this.debug("pathStepDocs - " + pathStepDocs);
+
+        var storyService = this;
+        var successCallback = function (data, status, xhr) {
+            storyService.debug("> fetchStepDocs.successCallback");
+            storyService.debug("status - " + status);
+            storyService.debug("xhr.status - " + xhr.status);
+            storyService.debug("data - " + data);
+
+            storyService.debug("found step docs - " + JSON.stringify(data, null, "\t"));
+
+            callback(data.stepDocs);
+
+            storyService.debug("# fetchStepDocs.successCallback");
+        };
+
+        AJS.$.ajax({
+            type: "GET",
+            url: pathStepDocs,
+            contentType: "text/plain; charset=utf-8",
+            success: successCallback,
+            dataType: "json"
+        });
+
+        this.debug("# fetchStepDocs");
+    }
 
 }
\ No newline at end of file
Index: execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/dto/stepdoc/StepDocDTOUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/dto/stepdoc/StepDocDTOUtils.java	(date 1406459024000)
+++ execspec/tests-2-master/execspec-parent/execspec-jira-plugin/src/main/java/com/mycomp/execspec/jiraplugin/dto/stepdoc/StepDocDTOUtils.java	(revision )
@@ -4,6 +4,7 @@
 import org.jbehave.core.steps.StepType;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -13,10 +14,26 @@
 
     public static void fromDTOToModel(StepDocDTO stepDocDTO, StepDoc stepDoc) {
 
-        stepDoc.setPattern(stepDocDTO.getPattern());
-        stepDoc.setStartingWord(stepDocDTO.getStartingWord());
         stepDoc.setStepType(stepDocDTO.getStepType().name());
+        stepDoc.setStartingWord(stepDocDTO.getStartingWord());
+        stepDoc.setPattern(stepDocDTO.getPattern());
+        stepDoc.setRegExpPattern(stepDocDTO.getRegExpPattern());
+        stepDoc.setGroupedRegExpPattern(stepDocDTO.getGroupedRegExpPattern());
+
+        List<Integer> parameterGroups = stepDocDTO.getParameterGroups();
+        if (parameterGroups != null && !parameterGroups.isEmpty()) {
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < parameterGroups.size(); i++) {
+                Integer parameterGroup = parameterGroups.get(i);
+                sb.append(parameterGroup.toString());
+                if (i < parameterGroups.size()-1) {
+                    sb.append(",");
-    }
+                }
+            }
+            String parameterGroupsAsString = sb.toString();
+            stepDoc.setParameterGroups(parameterGroupsAsString);
+        }
+    }
 
     public static StepDocDTO fromModelToDTO(StepDoc stepDoc) {
 
@@ -24,7 +41,21 @@
         String startingWord = stepDoc.getStartingWord();
         String pattern = stepDoc.getPattern();
         String regExpPattern = stepDoc.getRegExpPattern();
-        StepDocDTO stepDocDTO = new StepDocDTO(stepType, startingWord, pattern, regExpPattern);
+        String groupedRegExpPattern = stepDoc.getGroupedRegExpPattern();
+        String parameterGroupsStr = stepDoc.getParameterGroups();
+        List<Integer> parameterGroups;
+        if (parameterGroupsStr != null) {
+            String[] strGroups = parameterGroupsStr.split(",");
+            parameterGroups = new ArrayList<Integer>(strGroups.length);
+            for (String strGroup : strGroups) {
+                Integer intGroup = Integer.parseInt(strGroup);
+                parameterGroups.add(intGroup);
+            }
+        } else {
+            parameterGroups = Collections.emptyList();
+        }
+
+        StepDocDTO stepDocDTO = new StepDocDTO(stepType, startingWord, pattern, regExpPattern, groupedRegExpPattern, parameterGroups);
         return stepDocDTO;
     }
 
