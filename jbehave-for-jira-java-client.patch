Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/resources/ftl/jbehave-html-output.ftl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/resources/ftl/jbehave-html-output.ftl	(revision )
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/resources/ftl/jbehave-html-output.ftl	(revision )
@@ -0,0 +1,349 @@
+<#ftl strip_whitespace=true>
+
+<#--<#macro renderEmptyElement text><!-- story element - ${text?html} was empty &ndash;&gt;</#macro>-->
+<#macro renderMultiline text>${text?html?replace("\n", "<br/>")}</#macro>
+
+<#macro renderMeta meta>
+<div class="meta">
+	<div class="keyword">${keywords.meta}</div>
+    <#assign metaProperties=meta.getProperties()>
+    <#list metaProperties.keySet() as name>
+        <#assign property = metaProperties.get(name)>
+		<div class="property">${keywords.metaProperty}${name?html} ${property?html}</div>
+    </#list>
+</div>
+</#macro>
+
+<#macro renderNarrative narrative>
+<div class="narrative">
+	<div class="keyword">${keywords.narrative}</div>
+    <#assign isAlternative=narrative.isAlternative()?string>
+    <#if isAlternative == "true">
+		<div class="element asA"><span class="keyword asA">${keywords.asA}</span><span class="text"> ${narrative.asA}</span></div>
+		<div class="element iWantTo"><span class="keyword iWantTo">${keywords.iWantTo}</span><span class="text"> ${narrative.iWantTo}</span>
+		</div>
+		<div class="element soThat"><span class="keyword soThat">${keywords.soThat}</span><span class="text"> ${narrative.soThat}</span>
+		</div>
+    <#else>
+		<div class="element inOrderTo"><span class="keyword inOrderTo">${keywords.inOrderTo}</span><span
+				class="text"> ${narrative.inOrderTo}</span></div>
+		<div class="element asA"><span class="keyword asA">${keywords.asA}</span><span class="text"> ${narrative.asA}</span></div>
+		<div class="element iWantTo"><span class="keyword iWantTo">${keywords.iWantTo}</span><span class="text"> ${narrative.iWantTo}</span>
+		</div>
+    </#if>
+</div>
+</#macro>
+
+<#macro renderGivenStories givenStories>
+<div class="givenStories">
+	<div class="keyword">${keywords.givenStories}</div>
+    <#list givenStories.getStories() as givenStory>
+		<div class="givenStory">${givenStory.path}</div>
+    </#list>
+</div>
+</#macro>
+
+<#macro renderLifecycle lifecycle>
+<div class="lifecycle">
+	<div class="keyword">${keywords.lifecycle}</div>
+    <#if !lifecycle.getBeforeSteps().isEmpty()>
+		<div class="before">
+			<div class="keyword">${keywords.before}</div>
+            <#list lifecycle.getBeforeSteps() as step>
+            <#--<div class="step">${step?html}</div>-->
+                <@renderStep step/>
+            </#list>
+		</div>
+    </#if>
+    <#if !lifecycle.getAfterSteps().isEmpty()>
+		<div class="after">
+			<div class="keyword">${keywords.after}</div>
+            <#list lifecycle.getOutcomes() as outcome>
+				<div class="outcome">
+                    <#if lifecycle.getAfterSteps(outcome)?has_content>
+                    <#--TODO - there is no keyword currently for 'Outcome', will need to be localized below-->
+						<div><span class="keyword">Outcome:</span><span class="text"> ${outcome}</span></div>
+                        <#list lifecycle.getAfterSteps(outcome) as step>
+                            <@renderStep step/>
+                        </#list>
+                    </#if>
+				</div>
+            </#list>
+		</div>
+    </#if>
+</div>
+</#macro>
+
+<#macro renderTable table>
+    <#assign rows=table.getRows()>
+    <#assign headers=table.getHeaders()>
+    <#assign oddEven="odd">
+<table>
+	<thead>
+	<tr>
+        <#list headers as header>
+			<th>${header?html}</th>
+        </#list>
+	</tr>
+	</thead>
+	<tbody>
+        <#list rows as row>
+		<tr class="${oddEven}">
+            <#list headers as header>
+                <#assign cell=row.get(header)>
+				<td>${cell?html}</td>
+            </#list>
+		</tr>
+            <#if oddEven == "odd">
+                <#assign oddEven="even">
+            <#else>
+                <#assign oddEven="odd">
+            </#if>
+        </#list>
+	</tbody>
+</table>
+</#macro>
+
+<#macro renderOutcomeValue value dateFormat>
+    <#if value?is_date>${value?string(dateFormat)}<#else>${value?html}</#if>
+</#macro>
+
+<#macro renderOutcomes table>
+    <#assign outcomes=table.getOutcomes()>
+    <#assign fields=table.getOutcomeFields()>
+<span class="keyword">Outcomes:</span>
+<table>
+	<thead>
+	<tr>
+        <#list fields as field>
+			<th>${field?html}</th>
+        </#list>
+	</tr>
+	</thead>
+	<tbody>
+        <#list outcomes as outcome>
+            <#assign isVerified=outcome.isVerified()?string>
+            <#if isVerified == "true"> <#assign verified="verified"><#else><#assign verified="notVerified"></#if>
+		<tr class="${verified}">
+			<td>${outcome.description?html}</td>
+			<td><@renderOutcomeValue outcome.getValue() table.getDateFormat()/></td>
+			<td>${outcome.matcher?string}</td>
+			<td><#if isVerified == "true">${keywords.yes}<#else>${keywords.no}</#if></td>
+		</tr>
+        </#list>
+	</tbody>
+</table>
+</#macro>
+
+<#macro renderStep step>
+<#--<#assign formattedStep = step.getFormattedStep(EscapeMode.HTML, "<span class=\"step parameter\">{0}</span>")>-->
+<div class="step ${step.outcome}">
+<#--${formattedStep}-->
+
+    <#list step.getStepTokens() as token>
+        <#if token.getType() == "KEYWORD">
+			<span class="keyword">${token.asString()?html}</span>
+        <#elseif token.getType() == "TEXT">
+			<span class="text">${token.asString()?html}</span>
+        <#elseif token.getType() == "PARAMETER">
+			<span class="parameter">${token.asString()?html}</span>
+        <#elseif token.getType() == "TABULAR_PARAMETER">
+			<div class="tabular-parameter">
+                <@renderTable token.getTable()/>
+			</div>
+        </#if>
+    </#list>
+    <@renderStepOutcome step/>
+</div>
+</#macro>
+
+<#macro renderStepOutcome step>
+<div class="step-outcome">
+    <#assign outcome = step.getOutcome()>
+    <#if outcome=="passed">
+		<span class="outcome-keyword ${outcome}">(PASSED)</span>
+    </#if>
+    <#if outcome=="pending">
+		<span class="outcome-keyword ${outcome}">(${keywords.pending})</span>
+    </#if>
+    <#if outcome=="failed">
+		<span class="outcome-keyword ${outcome}">(${keywords.failed})</span>
+    </#if>
+    <#if outcome=="not_performed">
+		<span class="outcome-keyword ${outcome}">(${keywords.notPerformed})</span>
+    </#if>
+    <#if outcome=="ignored">
+		<span class="outcome-keyword ${outcome}">(${keywords.ignorable})</span>
+    </#if>
+
+    <#if step.getFailure()??>
+    <#-- render failure trace-->
+		<span class="step-failure">
+            <#if step.getUnderlyingErrorMsg()??>
+	            <span class="failure-msg">Underlying error - ${step.getUnderlyingErrorMsg()}</span>
+            </#if>
+			<a href="#" onclick="toggleFailureTrace(event);"><span class="failure-show-trace-trigger"
+			                                                       replace-text="hide trace">show trace</span></a>
+			<div class="failure-trace" style="display: none;">
+				<pre class="failure">${step.failureCause?html}</pre>
+			</div>
+        </span>
+    </#if>
+
+    <#if step.getOutcomes()??>
+		<div class="outcomes">
+            <@renderOutcomes step.getOutcomes()/>
+		</div>
+    </#if>
+
+</div>
+</#macro>
+
+<#-- report start ======================================================================================================================-->
+
+<div class="jb-story-report">
+
+<#if story.getDescription()??>
+	<div class="description">
+        <@renderMultiline story.getDescription()/>
+	</div>
+</#if>
+
+<#if story.getMeta()??><@renderMeta story.getMeta()/></#if>
+
+<#if story.getNarrative()??><@renderNarrative story.getNarrative()/></#if>
+
+<#if story.getLifecycle()??><@renderLifecycle story.getLifecycle()/></#if>
+
+<#assign scenarios = story.getScenarios()>
+<#assign scenarioIndex = 0>
+<#list scenarios as scenario>
+    <#assign scenarioContentId = "scenario_" + scenarioIndex + "_content">
+    <#assign scenarioTriggerContentId = "scenario_" + scenarioIndex + "_content_trigger">
+    <#if scenario.getOutcome() == "passed" || scenario.getOutcome() == "ignored" || scenario.getOutcome() == "not_performed">
+        <#assign contentCollapsedOrExpanded = "collapsed">
+    <#else>
+        <#assign contentCollapsedOrExpanded = "expanded">
+    </#if>
+	<div class="scenario ${scenario.getOutcome()}">
+		<div id="${scenarioTriggerContentId}" class="title jb-story-ele-exp-trigger ${contentCollapsedOrExpanded}">
+			<a href="#" onclick="storyReportToggleElement(event, '${scenarioContentId}', '${scenarioTriggerContentId}');">
+				<span class="keyword">${keywords.scenario}</span>
+				<span class="text"> <@renderMultiline scenario.getTitle()/></span>
+                <#if scenario.getOutcome() == "passed">
+					<span class="aui-lozenge aui-lozenge-success">passed</span>
+                <#elseif scenario.getOutcome() == "failed">
+					<span class="aui-lozenge aui-lozenge-error">failed</span>
+                <#elseif scenario.getOutcome() == "pending">
+					<span class="aui-lozenge aui-lozenge-current">pending</span>
+                <#elseif scenario.getOutcome() == "not_performed">
+					<span class="aui-lozenge">not performed</span>
+                <#elseif scenario.getOutcome() == "ignored">
+					<span class="aui-lozenge aui-lozenge-moved">ignored</span>
+                </#if>
+			</a>
+		</div>
+		<div id="${scenarioContentId}" class="content ${contentCollapsedOrExpanded}">
+            <#if scenario.getMeta()??><@renderMeta scenario.getMeta()/></#if>
+            <#if scenario.getGivenStories()??><@renderGivenStories scenario.getGivenStories()/></#if>
+            <#if scenario.getExamplesTable()??>
+				<div class="examples">
+					<div class="examples-keyword">${keywords.examplesTable}</div>
+					<div class="examples-table">
+                        <@renderTable scenario.getExamplesTable()/>
+					</div>
+                <#--examples themselves-->
+                    <#if scenario.getExamples()??>
+                        <#list scenario.getExamples() as example>
+							<div class="example">
+								<div class="title">
+									<span class="keyword">${keywords.examplesTableRow}</span><span class="text"> ${example?html}</span>
+								</div>
+                                <#assign steps = scenario.getStepsByExample(example)>
+                                <#list steps as step>
+                                    <@renderStep step/>
+                                </#list>
+							</div>
+                        </#list>
+                    </#if>
+				</div>
+				<!-- end examples -->
+            <#else> <!-- normal scenario steps -->
+				<div class="steps">
+                    <#assign steps = scenario.getSteps()>
+                <#list steps as step>
+                    <@renderStep step/>
+                </#list>
+				</div>
+            </#if>
+        <#--<#if scenario.getPendingMethods()??>-->
+        <#--<#list scenario.getPendingMethods() as method>-->
+        <#--<div>-->
+        <#--<pre class="pending">${method?html}</pre>-->
+        <#--</div>-->
+        <#--</#list>-->
+        <#--</#if>-->
+		</div>
+	</div>
+	<!-- end scenario -->
+    <#assign scenarioIndex = scenarioIndex + 1>
+</#list>
+<#if story.isCancelled()?string == 'true'>
+	<div class="cancelled">${keywords.storyCancelled} (${keywords.duration} ${story.storyDuration.durationInSecs} s)</div>
+</#if>
+</div>
+<!-- end story -->
+
+<#-- report end ========================================================================================================================-->
+
+<script type="text/javascript">
+
+	function toggleFailureTrace(event) {
+		AJS.$(event.target).closest(".step-failure").find(".failure-trace").each(function (index, element) {
+			AJS.$(element).toggle();
+			var replaceText = event.target.getAttribute("replace-text");
+			var currentHtml = AJS.$(event.target).html();
+			AJS.$(event.target).html(replaceText);
+			event.target.setAttribute("replace-text", currentHtml);
+		});
+		if (event.preventDefault) {
+			event.preventDefault();
+		} else {
+			event.returnValue = false;
+		}
+	}
+
+	function storyReportToggleElement(event, idOfElementToToggle, idOfTrigger) {
+		if (AJS.$("#" + idOfElementToToggle).hasClass("expanded")) {
+			AJS.$("#" + idOfElementToToggle).removeClass("expanded");
+			AJS.$("#" + idOfTrigger).removeClass("expanded");
+			AJS.$("#" + idOfElementToToggle).addClass("collapsed");
+			AJS.$("#" + idOfTrigger).addClass("collapsed");
+		} else {
+			AJS.$("#" + idOfElementToToggle).removeClass("collapsed");
+			AJS.$("#" + idOfTrigger).removeClass("collapsed");
+			AJS.$("#" + idOfElementToToggle).addClass("expanded");
+			AJS.$("#" + idOfTrigger).addClass("expanded");
+//			AJS.$("#" + idOfTrigger).mouseover(function (event) {
+//				AJS.$("#" + idOfTrigger).addClass("mouse-over");
+//			});
+//			AJS.$("#" + idOfTrigger).mouseout(function (event) {
+//				AJS.$("#" + idOfTrigger).removeClass("mouse-over");
+//			});
+		}
+		if (event.preventDefault) {
+			event.preventDefault();
+		} else {
+			event.returnValue = false;
+		}
+	}
+	AJS.$('.jb-story-ele-exp-trigger').mouseover(function (event) {
+		var target = AJS.$(event.target)[0];
+		AJS.$(target).closest(".jb-story-ele-exp-trigger").addClass("mouse-over");
+	});
+
+	AJS.$('.jb-story-ele-exp-trigger').mouseout(function (event) {
+		var target = AJS.$(event.target)[0];
+		AJS.$(target).closest(".jb-story-ele-exp-trigger").removeClass("mouse-over");
+	});
+</script>
\ No newline at end of file
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryReporter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryReporter.java	(date 1413310697000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryReporter.java	(revision )
@@ -1,152 +1,1153 @@
 package com.jbehaveforjira.javaclient;
 
+import com.sun.jersey.api.client.Client;
+import com.sun.jersey.api.client.WebResource;
+import freemarker.ext.beans.BeansWrapper;
+import freemarker.template.TemplateHashModel;
+import freemarker.template.TemplateModelException;
+import org.apache.commons.lang.StringEscapeUtils;
+import org.apache.commons.lang.StringUtils;
+import org.apache.commons.lang.Validate;
+import org.jbehave.core.annotations.AfterScenario;
+import org.jbehave.core.configuration.Keywords;
 import org.jbehave.core.model.*;
-import org.jbehave.core.reporters.StoryReporter;
+import org.jbehave.core.reporters.*;
+import org.jbehave.core.steps.StepCreator;
 
+import javax.ws.rs.core.MediaType;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.io.*;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /**
  * @author Maryna Pristrom
  */
 public class JiraStoryReporter implements StoryReporter {
 
-    private final StoryReporter storyReporter;
+    public static enum TestStatus {
 
-    private final String environment;
+        passed,
 
-    public JiraStoryReporter(String jiraBaseUrl, String jiraProject, String jiraUsername, String jiraPassword, String environment) {
+        failed,
 
-        this.environment = environment;
+        pending,
 
-        String[] constructorArgs = {jiraBaseUrl, jiraProject, jiraUsername, jiraPassword, environment};
-        this.storyReporter = GroovyResourceHelper.loadGroovyResource(
-                jiraBaseUrl, "story-reporter", jiraUsername, jiraPassword, "StoryReporter",
-                constructorArgs);
+        not_performed,
+
+        ignored
+
     }
 
-    @Override
-    public void storyNotAllowed(Story story, String filter) {
-        storyReporter.storyNotAllowed(story, filter);
+    private String basePostPath;
+    private String loginParams;
+
+    private final File file;
+    private final Keywords keywords;
+    private final TemplateProcessor processor;
+    private final String templatePath;
+    private OutputStory outputStory = new OutputStory();
+    private OutputScenario outputScenario = new OutputScenario();
+    private OutputStep failedStep;
+    private String environment;
+
+    public JiraStoryReporter(File file, Keywords keywords,
+                                       String jiraBaseUrl, String jiraProject, String username, String password, String environment) {
+        this(file, keywords, new FreemarkerProcessor(), "ftl/jbehave-html-output.ftl", jiraBaseUrl, jiraProject, username, password, environment);
     }
 
-    @Override
-    public void storyCancelled(Story story, StoryDuration storyDuration) {
-        storyReporter.storyCancelled(story, storyDuration);
+    public JiraStoryReporter(File file, Keywords keywords, TemplateProcessor processor, String templatePath,
+                                       String jiraBaseUrl, String jiraProject, String username, String password, String environment) {
+        this.file = file;
+        this.keywords = keywords;
+        this.processor = processor;
+        this.templatePath = templatePath;
+        this.loginParams = "?os_username=" + username + "&os_password=" + password;
+        this.basePostPath = jiraBaseUrl + "/rest/jbehave-for-jira/1.0/story-test/add-for-path/";
+        this.environment = environment;
     }
 
-    @Override
-    public void beforeStory(Story story, boolean givenStory) {
-        storyReporter.beforeStory(story, givenStory);
+    public void storyNotAllowed(Story story, String filter) {
+        this.outputStory.notAllowedBy = filter;
     }
 
-    @Override
-    public void afterStory(boolean givenStory) {
-        storyReporter.afterStory(givenStory);
+    public void beforeStory(Story story, boolean givenStory) {
+        if (!givenStory) {
+            this.outputStory = new OutputStory();
+            this.outputStory.description = story.getDescription().asString();
+            this.outputStory.path = story.getPath();
-    }
+        }
+        if (!story.getMeta().isEmpty()) {
+            this.outputStory.meta = new OutputMeta(story.getMeta());
+        }
+    }
 
-    @Override
     public void narrative(Narrative narrative) {
-        storyReporter.narrative(narrative);
+        if (!narrative.isEmpty()) {
+            this.outputStory.narrative = new OutputNarrative(narrative);
-    }
+        }
+    }
 
-    @Override
     public void lifecyle(Lifecycle lifecycle) {
-        storyReporter.lifecyle(lifecycle);
+        if (!lifecycle.isEmpty()) {
+            this.outputStory.lifecycle = new OutputLifecycle(lifecycle);
-    }
+        }
+    }
 
-    @Override
+
     public void scenarioNotAllowed(Scenario scenario, String filter) {
-        storyReporter.scenarioNotAllowed(scenario, filter);
+        this.outputScenario.notAllowedBy = filter;
     }
 
-    @Override
-    public void beforeScenario(String scenarioTitle) {
-        storyReporter.beforeScenario(scenarioTitle);
+    public void beforeScenario(String title) {
+        if (this.outputScenario.currentExample == null) {
+            this.outputScenario = new OutputScenario();
+            this.failedStep = null;
-    }
+        }
+        this.outputScenario.title = title;
+    }
 
-    @Override
-    public void scenarioMeta(Meta meta) {
-        storyReporter.scenarioMeta(meta);
+    public void beforeStep(String step) {
     }
 
-    @Override
-    public void afterScenario() {
-        storyReporter.afterScenario();
+    public void successful(String step) {
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.passed));
     }
 
-    @Override
+    public void ignorable(String step) {
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.ignored));
+    }
+
+    public void pending(String step) {
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.pending));
+    }
+
+    public void notPerformed(String step) {
+        this.outputScenario.addStep(new OutputStep(step, TestStatus.not_performed));
+    }
+
+    public void failed(String step, Throwable storyFailure) {
+        this.failedStep = new FailedOutputStep(step, TestStatus.failed, storyFailure);
+        this.outputScenario.addStep(failedStep);
+    }
+
+    public void failedOutcomes(String step, OutcomesTable table) {
+        failed(step, table.failureCause());
+        this.failedStep.outcomes = table;
+    }
+
     public void givenStories(GivenStories givenStories) {
-        storyReporter.givenStories(givenStories);
+        if (!givenStories.getStories().isEmpty()) {
+            this.outputScenario.givenStories = givenStories;
-    }
+        }
+    }
 
-    @Override
     public void givenStories(List<String> storyPaths) {
-        storyReporter.givenStories(storyPaths);
+        givenStories(new GivenStories(StringUtils.join(storyPaths, ",")));
     }
 
-    @Override
+    public void scenarioMeta(Meta meta) {
+        if (!meta.isEmpty()) {
+            this.outputScenario.meta = new OutputMeta(meta);
+        }
+    }
+
     public void beforeExamples(List<String> steps, ExamplesTable table) {
-        storyReporter.beforeExamples(steps, table);
+        this.outputScenario.examplesTable = table;
     }
 
-    @Override
-    public void example(Map<String, String> tableRow) {
-        storyReporter.example(tableRow);
+    public void example(Map<String, String> parameters) {
+        this.outputScenario.examples.add(parameters);
+        this.outputScenario.currentExample = parameters;
     }
 
-    @Override
     public void afterExamples() {
-        storyReporter.afterExamples();
+        this.outputScenario.currentExample = null;
     }
 
-    @Override
-    public void beforeStep(String step) {
-        storyReporter.beforeStep(step);
+    public void dryRun() {
     }
 
-    @Override
-    public void successful(String step) {
-        storyReporter.successful(step);
+    public void afterScenario() {
+        if (this.outputScenario.currentExample == null) {
+
+            // set scenario status
+            if (failedStep != null) {
+                this.outputScenario.outcome = TestStatus.failed.name();
+            } else if (this.outputScenario.pendingMethods != null) {
+                this.outputScenario.outcome = TestStatus.pending.name();
+            } else {
+                // check if all steps were skipped
+                List<OutputStep> scenarioSteps = outputScenario.steps;
+                boolean allSkipped = true;
+                for (OutputStep scenarioStep : scenarioSteps) {
+                    TestStatus stepOutcome = scenarioStep.outcome;
+                    if (stepOutcome != TestStatus.not_performed) {
+                        allSkipped = false;
+                        break;
-    }
+                    }
+                }
+                if (allSkipped) {
+                    this.outputScenario.outcome = TestStatus.not_performed.name();
+                } else {
+                    // check if all ignored
+                    boolean allIgnored = true;
+                    for (OutputStep scenarioStep : scenarioSteps) {
+                        TestStatus stepOutcome = scenarioStep.outcome;
+                        if (stepOutcome != TestStatus.ignored) {
+                            allIgnored = false;
+                            break;
+                        }
+                    }
+                    if (allIgnored) {
+                        this.outputScenario.outcome = TestStatus.ignored.name();
+                    } else {
+                        this.outputScenario.outcome = TestStatus.passed.name();
+                    }
+                }
+            }
 
-    @Override
-    public void ignorable(String step) {
-        storyReporter.ignorable(step);
+            this.outputStory.scenarios.add(outputScenario);
-    }
+        }
+    }
 
-    @Override
-    public void pending(String step) {
-        storyReporter.pending(step);
+    public void pendingMethods(List<String> methods) {
+        this.outputScenario.pendingMethods = methods;
     }
 
-    @Override
-    public void notPerformed(String step) {
-        storyReporter.notPerformed(step);
+    public void restarted(String step, Throwable cause) {
+        this.outputScenario.addStep(new OutputRestart(step, cause.getMessage()));
     }
 
-    @Override
-    public void failed(String step, Throwable cause) {
-        storyReporter.failed(step, cause);
+    public void storyCancelled(Story story, StoryDuration storyDuration) {
+        this.outputStory.cancelled = true;
+        this.outputStory.storyDuration = storyDuration;
     }
 
-    @Override
-    public void failedOutcomes(String step, OutcomesTable table) {
-        storyReporter.failedOutcomes(step, table);
+    public void afterStory(boolean givenStory) {
+        if (!givenStory && !outputStory.getPath().equals("AfterStories") && !outputStory.getPath().equals("BeforeStories")) {
+
+            Map<String, Object> model = newDataModel();
+            model.put("story", outputStory);
+            model.put("keywords", new OutputKeywords(keywords));
+
+            BeansWrapper wrapper = BeansWrapper.getDefaultInstance();
+            TemplateHashModel enumModels = wrapper.getEnumModels();
+            TemplateHashModel escapeEnums;
+            try {
+
+                String escapeModeEnum = EscapeMode.class.getCanonicalName();
+                escapeEnums = (TemplateHashModel) enumModels.get(escapeModeEnum);
+                model.put("EscapeMode", escapeEnums);
+
+            } catch (TemplateModelException e) {
+                throw new IllegalArgumentException(e);
-    }
+            }
 
-    @Override
-    public void restarted(String step, Throwable cause) {
-        storyReporter.restarted(step, cause);
+            write(file, templatePath, model);
+
+            // write to string stream
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            OutputStreamWriter outStreamWriter = new OutputStreamWriter(out);
+            processor.process(templatePath, model, outStreamWriter);
+            String report = out.toString();
+            sendStoryReport(report, outputStory);
+
-    }
+        }
+    }
 
-    @Override
-    public void dryRun() {
-        storyReporter.dryRun();
+    private File write(File file, String resource, Map<String, Object> dataModel) {
+        try {
+
+            // write to file
+            File parentFile = file.getParentFile();
+            if (parentFile != null) {
+                parentFile.mkdirs();
-    }
+            }
+            Writer writer = new FileWriter(file);
+            processor.process(resource, dataModel, writer);
+            writer.close();
 
-    @Override
-    public void pendingMethods(List<String> methods) {
-        storyReporter.pendingMethods(methods);
+            return file;
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw new RuntimeException(resource, e);
-    }
-}
+        }
+    }
+
+    protected void sendStoryReport(String testReport, OutputStory outputStory) {
+
+        Validate.notEmpty(testReport);
+
+        // extract version
+        long jiraVersion;
+        String actualStoryPath;
+        String regexPattern = "(.*)\\.([0-9]*)(\\.story)";
+        Pattern p = Pattern.compile(regexPattern);
+        Matcher matcher = p.matcher(outputStory.getPath());
+        if (matcher.matches()) {
+            actualStoryPath = matcher.group(1) + matcher.group(3);
+            String versionStr = matcher.group(2);
+            jiraVersion = Long.parseLong(versionStr);
+        } else {
+            throw new IllegalArgumentException("JiraStory path must match pattern - " + regexPattern);
+        }
+
+        List<OutputScenario> scenarios = outputStory.getScenarios();
+        int totalScenarios = 0;
+        int totalPassed = 0;
+        int totalFailed = 0;
+        int totalPending = 0;
+        int totalNotPerformed = 0;
+        int totalIgnored = 0;
+        for (OutputScenario scenario : scenarios) {
+            totalScenarios++;
+            String outcome = scenario.getOutcome();
+            if (TestStatus.passed.name().equals(outcome)) {
+                totalPassed++;
+            } else if (TestStatus.failed.name().equals(outcome)) {
+                totalFailed++;
+            } else if (TestStatus.pending.name().equals(outcome)) {
+                totalPending++;
+            } else if (TestStatus.not_performed.name().equals(outcome)) {
+                totalNotPerformed++;
+            } else if (TestStatus.ignored.name().equals(outcome)) {
+                totalIgnored++;
+            }
+        }
+
+        TestStatus storyStatus;
+        if (totalFailed > 0) {
+            storyStatus = TestStatus.failed;
+        } else if (totalPending > 0) {
+            storyStatus = TestStatus.pending;
+        } else if (totalNotPerformed > 0 && totalNotPerformed == totalScenarios) {
+            storyStatus = TestStatus.not_performed;
+        } else if (totalIgnored > 0 && totalIgnored == totalScenarios) {
+            storyStatus = TestStatus.ignored;
+        } else {
+            storyStatus = TestStatus.passed;
+        }
+
+        StoryReport storyHtmlReportDTO = new StoryReport(environment,
+                outputStory.getPath(), jiraVersion, storyStatus, testReport);
+
+        storyHtmlReportDTO.setTotalScenarios(totalScenarios);
+        storyHtmlReportDTO.setTotalScenariosPassed(totalPassed);
+        storyHtmlReportDTO.setTotalScenariosFailed(totalFailed);
+        storyHtmlReportDTO.setTotalScenariosPending(totalPending);
+        storyHtmlReportDTO.setTotalScenariosIgnored(totalIgnored);
+        storyHtmlReportDTO.setTotalScenariosNotPerformed(totalNotPerformed);
+
+        // extract version
+
+        String postUrl = this.basePostPath + actualStoryPath + loginParams;
+
+        Client client = Client.create();
+        WebResource res = client.resource(postUrl);
+
+        String response = res.accept(MediaType.APPLICATION_JSON)
+                .type(MediaType.APPLICATION_JSON)
+                .post(String.class, storyHtmlReportDTO);
+
+        System.out.println("response - " + response);
+    }
+
+    private Map<String, Object> newDataModel() {
+        return new HashMap<String, Object>();
+    }
+
+    public static class OutputKeywords {
+
+        private final Keywords keywords;
+
+        public OutputKeywords(Keywords keywords) {
+            this.keywords = keywords;
+        }
+
+        public String getLifecycle() {
+            return keywords.lifecycle();
+        }
+
+        public String getBefore() {
+            return keywords.before();
+        }
+
+        public String getAfter() {
+            return keywords.after();
+        }
+
+        public String getMeta() {
+            return keywords.meta();
+        }
+
+        public String getMetaProperty() {
+            return keywords.metaProperty();
+        }
+
+        public String getNarrative() {
+            return keywords.narrative();
+        }
+
+        public String getInOrderTo() {
+            return keywords.inOrderTo();
+        }
+
+        public String getAsA() {
+            return keywords.asA();
+        }
+
+        public String getiWantTo() {
+            return keywords.iWantTo();
+        }
+
+        public String getSoThat() {
+            return keywords.soThat();
+        }
+
+        public String getScenario() {
+            return keywords.scenario();
+        }
+
+        public String getGivenStories() {
+            return keywords.givenStories();
+        }
+
+        public String getExamplesTable() {
+            return keywords.examplesTable();
+        }
+
+        public String getExamplesTableRow() {
+            return keywords.examplesTableRow();
+        }
+
+        public String getExamplesTableHeaderSeparator() {
+            return keywords.examplesTableHeaderSeparator();
+        }
+
+        public String getExamplesTableValueSeparator() {
+            return keywords.examplesTableValueSeparator();
+        }
+
+        public String getExamplesTableIgnorableSeparator() {
+            return keywords.examplesTableIgnorableSeparator();
+        }
+
+        public String getGiven() {
+            return keywords.given();
+        }
+
+        public String getWhen() {
+            return keywords.when();
+        }
+
+        public String getThen() {
+            return keywords.then();
+        }
+
+        public String getAnd() {
+            return keywords.and();
+        }
+
+        public String getIgnorable() {
+            return keywords.ignorable();
+        }
+
+        public String getPending() {
+            return keywords.pending();
+        }
+
+        public String getNotPerformed() {
+            return keywords.notPerformed();
+        }
+
+        public String getFailed() {
+            return keywords.failed();
+        }
+
+        public String getDryRun() {
+            return keywords.dryRun();
+        }
+
+        public String getStoryCancelled() {
+            return keywords.storyCancelled();
+        }
+
+        public String getDuration() {
+            return keywords.duration();
+        }
+
+        public String getYes() {
+            return keywords.yes();
+        }
+
+        public String getNo() {
+            return keywords.no();
+        }
+    }
+
+    public static class OutputStory {
+        private String description;
+        private String path;
+        private OutputMeta meta;
+        private OutputNarrative narrative;
+        private OutputLifecycle lifecycle;
+        private String notAllowedBy;
+        private List<OutputScenario> scenarios = new ArrayList<OutputScenario>();
+        private boolean cancelled;
+        private StoryDuration storyDuration;
+
+        public String getDescription() {
+            return description;
+        }
+
+        public String getPath() {
+            return path;
+        }
+
+        public OutputMeta getMeta() {
+            return meta;
+        }
+
+        public OutputNarrative getNarrative() {
+            return narrative;
+        }
+
+        public OutputLifecycle getLifecycle() {
+            return lifecycle;
+        }
+
+        public String getNotAllowedBy() {
+            return notAllowedBy;
+        }
+
+        public List<OutputScenario> getScenarios() {
+            return scenarios;
+        }
+
+        public boolean isCancelled() {
+            return cancelled;
+        }
+
+        public StoryDuration getStoryDuration() {
+            return storyDuration;
+        }
+    }
+
+    public static class OutputMeta {
+
+        private final Meta meta;
+
+        public OutputMeta(Meta meta) {
+            this.meta = meta;
+        }
+
+        public Map<String, String> getProperties() {
+            Map<String, String> properties = new HashMap<String, String>();
+            for (String name : meta.getPropertyNames()) {
+                properties.put(name, meta.getProperty(name));
+            }
+            return properties;
+        }
+
+    }
+
+    public static class OutputNarrative {
+        private final Narrative narrative;
+
+        public OutputNarrative(Narrative narrative) {
+            this.narrative = narrative;
+        }
+
+        public String getInOrderTo() {
+            return narrative.inOrderTo();
+        }
+
+        public String getAsA() {
+            return narrative.asA();
+        }
+
+        public String getiWantTo() {
+            return narrative.iWantTo();
+        }
+
+        public String getSoThat() {
+            return narrative.soThat();
+        }
+
+        public boolean isAlternative() {
+            return narrative.isAlternative();
+        }
+
+    }
+
+    public static class OutputLifecycle {
+
+        private final Lifecycle lifecycle;
+
+        public OutputLifecycle(Lifecycle lifecycle) {
+            this.lifecycle = lifecycle;
+        }
+
+        public List<OutputStep> getBeforeSteps() {
+
+            List<OutputStep> beforeSteps = new ArrayList<OutputStep>();
+            List<String> beforeStrSteps = lifecycle.getBeforeSteps();
+            if (beforeStrSteps != null) {
+                for (String beforeStrStep : beforeStrSteps) {
+                    OutputStep step = new OutputStep(beforeStrStep, TestStatus.passed);
+                    beforeSteps.add(step);
+                }
+            }
+            return beforeSteps;
+        }
+
+        public List<OutputStep> getAfterSteps() {
+
+            List<OutputStep> afterSteps = new ArrayList<OutputStep>();
+
+            List<String> afterStrSteps = lifecycle.getAfterSteps();
+            lifecycle.getAfterSteps(AfterScenario.Outcome.FAILURE);
+            if (afterStrSteps != null) {
+                afterSteps = new ArrayList<OutputStep>();
+                for (String afterStrStep : afterStrSteps) {
+                    OutputStep step = new OutputStep(afterStrStep, TestStatus.passed);
+                    afterSteps.add(step);
+                }
+            }
+
+            return afterSteps;
+        }
+
+        public List<OutputStep> getAfterSteps(String strOutcome) {
+
+            AfterScenario.Outcome outcome = AfterScenario.Outcome.valueOf(strOutcome);
+
+            List<String> strAfterSteps = lifecycle.getAfterSteps(outcome);
+            List<OutputStep> afterSteps = new ArrayList<OutputStep>(strAfterSteps.size());
+            for (String strAfterStep : strAfterSteps) {
+                OutputStep step = new OutputStep(strAfterStep, TestStatus.passed);
+                afterSteps.add(step);
+            }
+
+            return afterSteps;
+        }
+
+        public List<String> getOutcomes() {
+
+            AfterScenario.Outcome[] outcomes = AfterScenario.Outcome.values();
+            List<String> strOutcomes = new ArrayList<String>(outcomes.length);
+            for (AfterScenario.Outcome outcome : outcomes ) {
+                strOutcomes.add(outcome.name());
+            }
+            return strOutcomes;
+        }
+    }
+
+    public static class OutputScenario {
+        private String title;
+        private String outcome;
+        private List<OutputStep> steps = new ArrayList<OutputStep>();
+        private OutputMeta meta;
+        private List<String> pendingMethods;
+        private GivenStories givenStories;
+        private String notAllowedBy;
+
+        private ExamplesTable examplesTable;
+        private Map<String, String> currentExample;
+        private List<Map<String, String>> examples = new ArrayList<Map<String, String>>();
+        private Map<Map<String, String>, List<OutputStep>> stepsByExample = new HashMap<Map<String, String>, List<OutputStep>>();
+
+        public String getTitle() {
+            return title;
+        }
+
+        public void addStep(OutputStep outputStep) {
+            if (examplesTable == null) {
+                steps.add(outputStep);
+            } else {
+                List<OutputStep> currentExampleSteps = stepsByExample.get(currentExample);
+                if (currentExampleSteps == null) {
+                    currentExampleSteps = new ArrayList<OutputStep>();
+                    stepsByExample.put(currentExample, currentExampleSteps);
+                }
+                currentExampleSteps.add(outputStep);
+            }
+        }
+
+        public List<String> getPendingMethods() {
+            return pendingMethods;
+        }
+
+        public String getOutcome() {
+            return outcome;
+        }
+
+        public List<OutputStep> getSteps() {
+            return steps;
+        }
+
+        public List<OutputStep> getStepsByExample(Map<String, String> example) {
+            List<OutputStep> steps = stepsByExample.get(example);
+            if (steps == null) {
+                return new ArrayList<OutputStep>();
+            }
+            return steps;
+        }
+
+        public OutputMeta getMeta() {
+            return meta;
+        }
+
+        public GivenStories getGivenStories() {
+            return givenStories;
+        }
+
+        public String getNotAllowedBy() {
+            return notAllowedBy;
+        }
+
+        public ExamplesTable getExamplesTable() {
+            return examplesTable;
+        }
+
+        public List<Map<String, String>> getExamples() {
+            return examples;
+        }
+
+    }
+
+    public static class OutputRestart extends OutputStep {
+
+        public OutputRestart(String step, String outcome) {
+            super(step, TestStatus.failed);
+        }
+
+    }
+
+    public static class FailedOutputStep extends OutputStep {
+
+        public FailedOutputStep(String step, TestStatus outcome, Throwable storyFailure) {
+            this.step = step;
+            this.outcome = outcome;
+            this.failure = storyFailure;
+            parse();
+        }
+    }
+
+    public static class OutputStep {
+
+        protected String step;
+
+        protected List<OutputStepToken> stepTokens;
+
+        protected TestStatus outcome;
+
+        protected Throwable failure;
+
+        protected OutcomesTable outcomes;
+
+        protected OutputStep() {
+        }
+
+        public OutputStep(String step, TestStatus outcome) {
+
+            this.step = step;
+            this.outcome = outcome;
+            parse();
+        }
+
+        protected void parse() {
+
+            stepTokens = new ArrayList<OutputStepToken>();
+
+            int indexOfFirstSpace = step.indexOf(" ");
+            Validate.isTrue(indexOfFirstSpace > -1);
+
+            String keyword = step.substring(0, indexOfFirstSpace);
+            stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.KEYWORD, keyword));
+
+            String stepBody = step.substring(indexOfFirstSpace);
+            stepBody = remarkBody(stepBody);
+
+            // find any parameter markers
+            Pattern simpleParamPattern = Pattern.compile(
+                    "(.*?)"
+                            // have to use '+' quantifier as parameterized steps are marked with invisible markers two times
+                            + "((\\" + StepCreator.PARAMETER_VALUE_START + ")+)"
+                            + "(.*?)"
+                            + "((\\" + StepCreator.PARAMETER_VALUE_END + ")+)"
+                            + "(.*)"
+                    , Pattern.DOTALL
+            );
+            Pattern tableParamPattern = Pattern.compile(
+                    "(.*?)"
+                            + "(\\" + StepCreator.PARAMETER_TABLE_START + ")"
+                            + "(.*?)"
+                            + "(\\" + StepCreator.PARAMETER_TABLE_END + ")"
+                            + "(.*)"
+                    , Pattern.DOTALL
+            );
+            int pos = 0;
+            Matcher simpleParamMatcher = simpleParamPattern.matcher(stepBody);
+            Matcher tableParamMatcher = tableParamPattern.matcher(stepBody);
+            while (pos < stepBody.length()) {
+
+                if (simpleParamMatcher.find(pos)) {
+                    // simple parameter
+                    String beforeParam = simpleParamMatcher.group(1);
+                    if (beforeParam != null) {
+                        stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, beforeParam));
+                    }
+                    String paramValue = simpleParamMatcher.group(4);
+                    stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.PARAMETER, paramValue));
+                    pos = simpleParamMatcher.end(5);
+                } else if (tableParamMatcher.find(pos)) {
+                    // tabular parameter
+                    String beforeParam = tableParamMatcher.group(1);
+                    if (beforeParam != null) {
+                        stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, beforeParam));
+                    }
+                    String paramValue = tableParamMatcher.group(3);
+                    stepTokens.add(new TabularParameterStepToken(paramValue));
+                    pos = tableParamMatcher.end(4);
+                } else {
+                    // no marked parameters left
+                    String remainingText = stepBody.substring(pos);
+                    stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, remainingText));
+                    pos = stepBody.length();
+                }
+
+            }
+
+
+        }
+
+        public String getStep() {
+            return step;
+        }
+
+        public List<OutputStepToken> getStepTokens() {
+            return stepTokens;
+        }
+
+        public String getOutcome() {
+            return outcome.name();
+        }
+
+        public Throwable getFailure() {
+            return failure;
+        }
+
+        public String getFailureCause() {
+            if (failure != null) {
+                return new StackTraceFormatter(false).stackTrace(failure);
+            }
+            return "";
+        }
+
+        public String getUnderlyingErrorMsg() {
+            Throwable underlyingCause = failure;
+            while (underlyingCause.getCause() != null) {
+                underlyingCause = underlyingCause.getCause();
+            }
+            String message = underlyingCause.getMessage();
+            if (message == null && underlyingCause instanceof OutcomesTable.OutcomesFailed) {
+                message = "Outcomes Failed";
+            }
+            return message;
+        }
+
+        public OutcomesTable getOutcomes() {
+            return outcomes;
+        }
+
+        public String getOutcomesFailureCause() {
+            if (outcomes.failureCause() != null) {
+                return new StackTraceFormatter(false).stackTrace(outcomes.failureCause());
+            }
+            return "";
+        }
+
+        private static String escapeString(String string) {
+            return StringEscapeUtils.escapeHtml(string);
+        }
+
+        private boolean containsTable(String text) {
+            return text.contains(StepCreator.PARAMETER_TABLE_START) && text.contains(StepCreator.PARAMETER_TABLE_END);
+        }
+
+        private String remarkBody(String stepBody) {
+
+            // custom work around for the fact that JBehave's step creator doesn't recognize custom types annotated
+            // with AsParameters as tabular parameters
+
+            String[] lines = stepBody.split(StepCreator.PARAMETER_VALUE_NEWLINE);
+
+            if (lines.length == 1) {
+                return stepBody;
+//                if (this.outcome == TestStatus.failed) {
+//                    // check if parsed error occurred
+//                    if (this.failure instanceof ExamplesTable.ParametersNotMappableToType
+//                            || (
+//                                this.failure instanceof UUIDExceptionWrapper
+//                                &&
+//                                ((UUIDExceptionWrapper)this.failure).getCause() instanceof ExamplesTable.ParametersNotMappableToType
+//                                )
+//                        ) {
+//                        // use case when we might have failed to parse the table parameter into custom type
+//                        // in this case we do still want to render them as table parameter in the story report
+//                        StringBuilder sb = new StringBuilder();
+//                        String[] bodyLines = stepBody.split("\n");
+//                        boolean inTable = false;
+//                        for (int i = 0; i < bodyLines.length; i++) {
+//                            String bodyLine = bodyLines[i];
+//                            if (!inTable && bodyLine.startsWith("|") && bodyLine.endsWith("|") && !bodyLine.startsWith("|--")) {
+//                                inTable = true;
+//                                sb.append(StepCreator.PARAMETER_TABLE_START);
+//                            }
+//                            if (inTable && (i == (bodyLines.length - 1) || !bodyLines[i + 1].startsWith("|"))) {
+//                                // this is last table line
+//                                int lastPipe = bodyLine.lastIndexOf("|");
+//                                sb.append(bodyLine.substring(0, lastPipe + 1));
+//                                sb.append(StepCreator.PARAMETER_TABLE_END);
+//                                sb.append(bodyLine.substring(lastPipe + 1));
+//                                inTable = false;
+//                            } else {
+//                                sb.append(bodyLine);
+//                            }
+//                            if (i != (bodyLines.length - 1)) {
+//                                sb.append("\n");
+//                            }
+//                        }
+//                        String result = sb.toString();
+//                        return result;
+//                    } else {
+//                        return stepBody;
+//                    }
+//                } else {
+//                    return stepBody;
+//                }
+            } else {
+
+//                boolean tableMarkedAlready = text.contains(StepCreator.PARAMETER_TABLE_START);
+
+                // use case for incorrectly marked tables
+                StringBuilder sb = new StringBuilder();
+                boolean inTable = false;
+                for (int i = 0; i < lines.length; i++) {
+                    String line = lines[i];
+                    if (!inTable && line.startsWith("|")) {
+                        inTable = true;
+                        sb.append(StepCreator.PARAMETER_TABLE_START);
+                    }
+                    if (inTable && (i == (lines.length - 1) || !lines[i + 1].startsWith("|"))) {
+                        // this is last table line
+                        int lastPipe = line.lastIndexOf("|");
+                        sb.append(line.substring(0, lastPipe + 1));
+                        sb.append(StepCreator.PARAMETER_TABLE_END);
+                        sb.append(line.substring(lastPipe + 1));
+                        inTable = false;
+                    } else {
+                        sb.append(line);
+                    }
+                    if (i != (lines.length - 1)) {
+                        sb.append("\n");
+                    }
+                }
+
+                String result = sb.toString();
+                return result;
+            }
+        }
+
+//        @SuppressWarnings("serial")
+//        public static class StepFormattingFailed extends RuntimeException {
+//
+//            public StepFormattingFailed(String stepPattern, String parameterPattern, List<OutputParameter> parameters,
+//                                        RuntimeException cause) {
+//                super("Failed to format step '" + stepPattern + "' with parameter pattern '" + parameterPattern
+//                        + "' and parameters: " + parameters, cause);
+//            }
+//
+//        }
+
+    }
+
+    public static class OutputStepToken {
+
+        public static enum StepTokenType {
+            KEYWORD,
+            TEXT,
+            PARAMETER,
+            TABULAR_PARAMETER
+        }
+
+        private StepTokenType type;
+        private String asString;
+
+        protected OutputStepToken(StepTokenType type, String asString) {
+            this.asString = asString;
+            this.type = type;
+        }
+
+        public StepTokenType getType() {
+            return type;
+        }
+
+        public String asString() {
+            return asString;
+        }
+    }
+
+    public static class TabularParameterStepToken extends OutputStepToken {
+
+        private ExamplesTable table;
+
+        protected TabularParameterStepToken(String asString) {
+            super(StepTokenType.TABULAR_PARAMETER, asString);
+            table = new ExamplesTable(asString);
+        }
+
+        public ExamplesTable getTable() {
+            return table;
+        }
+    }
+
+    @XmlRootElement
+    @XmlAccessorType(XmlAccessType.FIELD)
+    public static class StoryReport {
+
+        private String environment;
+
+        private String storyPath;
+
+        private Long storyVersion;
+
+        public TestStatus status;
+
+        private Integer totalScenarios;
+
+        private Integer totalScenariosPassed;
+
+        private Integer totalScenariosFailed;
+
+        private Integer totalScenariosPending;
+
+        private Integer totalScenariosIgnored;
+
+        private Integer totalScenariosNotPerformed;
+
+        private String htmlReport;
+
+        protected StoryReport() {
+        }
+
+        public StoryReport(String environment, String storyPath,
+                           Long storyVersion, TestStatus status, String htmlReport) {
+            this.environment = environment;
+            this.storyPath = storyPath;
+            this.storyVersion = storyVersion;
+            this.status = status;
+            this.htmlReport = htmlReport;
+        }
+
+        public String getEnvironment() {
+            return environment;
+        }
+
+        public void setEnvironment(String environment) {
+            this.environment = environment;
+        }
+
+        public String getStoryPath() {
+            return storyPath;
+        }
+
+        public void setStoryPath(String storyPath) {
+            this.storyPath = storyPath;
+        }
+
+        public Long getStoryVersion() {
+            return storyVersion;
+        }
+
+        public void setStoryVersion(Long storyVersion) {
+            this.storyVersion = storyVersion;
+        }
+
+        public TestStatus getStatus() {
+            return status;
+        }
+
+        public void setStatus(TestStatus status) {
+            this.status = status;
+        }
+
+        public String getHtmlReport() {
+            return htmlReport;
+        }
+
+        public void setHtmlReport(String htmlReport) {
+            this.htmlReport = htmlReport;
+        }
+
+        public Integer getTotalScenarios() {
+            return totalScenarios;
+        }
+
+        public void setTotalScenarios(Integer totalScenarios) {
+            this.totalScenarios = totalScenarios;
+        }
+
+        public Integer getTotalScenariosPassed() {
+            return totalScenariosPassed;
+        }
+
+        public void setTotalScenariosPassed(Integer totalScenariosPassed) {
+            this.totalScenariosPassed = totalScenariosPassed;
+        }
+
+        public Integer getTotalScenariosFailed() {
+            return totalScenariosFailed;
+        }
+
+        public void setTotalScenariosFailed(Integer totalScenariosFailed) {
+            this.totalScenariosFailed = totalScenariosFailed;
+        }
+
+        public Integer getTotalScenariosPending() {
+            return totalScenariosPending;
+        }
+
+        public void setTotalScenariosPending(Integer totalScenariosPending) {
+            this.totalScenariosPending = totalScenariosPending;
+        }
+
+        public Integer getTotalScenariosIgnored() {
+            return totalScenariosIgnored;
+        }
+
+        public void setTotalScenariosIgnored(Integer totalScenariosIgnored) {
+            this.totalScenariosIgnored = totalScenariosIgnored;
+        }
+
+        public Integer getTotalScenariosNotPerformed() {
+            return totalScenariosNotPerformed;
+        }
+
+        public void setTotalScenariosNotPerformed(Integer totalScenariosNotPerformed) {
+            this.totalScenariosNotPerformed = totalScenariosNotPerformed;
+        }
+
+    }
+
+}
+
+
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStepDocReporter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStepDocReporter.java	(date 1413310697000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStepDocReporter.java	(revision )
@@ -1,36 +1,526 @@
 package com.jbehaveforjira.javaclient;
 
+import com.sun.jersey.api.client.Client;
+import org.apache.commons.lang.Validate;
+import org.codehaus.jackson.map.ObjectMapper;
+import org.jbehave.core.annotations.AsParameters;
+import org.jbehave.core.annotations.Parameter;
+import org.jbehave.core.model.StepPattern;
+import org.jbehave.core.parsers.RegexPrefixCapturingPatternParser;
+import org.jbehave.core.parsers.StepMatcher;
+import org.jbehave.core.parsers.StepPatternParser;
 import org.jbehave.core.reporters.StepdocReporter;
+import org.jbehave.core.steps.StepType;
 import org.jbehave.core.steps.Stepdoc;
 
+import javax.ws.rs.core.MediaType;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /**
  * @author Maryna Pristrom
  */
 public class JiraStepDocReporter implements StepdocReporter {
 
-    private final StepdocReporter stepdocReporter;
+    private final String reportStepDocUrl;
 
+    private final StepPatternParser patternParser;
+
     public JiraStepDocReporter(String jiraBaseUrl, String jiraProject, String jiraUserName, String jiraPassword) {
+        this(jiraBaseUrl, jiraProject, jiraUserName, jiraPassword, new RegexPrefixCapturingPatternParser());
+    }
 
-        String[] constructorArgs = {jiraBaseUrl, jiraProject, jiraUserName, jiraPassword};
-        this.stepdocReporter = GroovyResourceHelper.loadGroovyResource(
-                jiraBaseUrl, "step-doc-reporter",
-                jiraUserName, jiraPassword,
-                "StepDocReporter", constructorArgs);
+    public JiraStepDocReporter(String jiraBaseUrl, String jiraProject, String jiraUserName, String jiraPassword, StepPatternParser stepPatternParser) {
+        this.reportStepDocUrl = (jiraBaseUrl + "/rest/jbehave-for-jira/1.0/step-doc/add/" + jiraProject
+                + "?os_username=" + jiraUserName
+                + "&os_password=" + jiraPassword);
+        this.patternParser = stepPatternParser;
     }
 
     @Override
     public void stepdocs(List<Stepdoc> stepdocs, List<Object> stepsInstances) {
 
-        this.stepdocReporter.stepdocs(stepdocs, stepsInstances);
+        List<StepDocDTO> stepDocDTOs = new ArrayList<StepDocDTO>(stepdocs.size());
+
+        for (Stepdoc stepdoc : stepdocs) {
+
+            StepDocDTO stepDocDTO = new StepDocDTO();
+
+            String pattern = stepdoc.getPattern();
+            stepDocDTO.pattern = pattern;
+
+            StepType stepType = stepdoc.getStepType();
+
+            String startingWord = stepdoc.getStartingWord();
+            stepDocDTO.startingWord = startingWord;
+
+            Object stepsInstance = stepdoc.getStepsInstance();
+            Class<?> stepsClass = stepsInstance.getClass();
+            String stepClassName = stepsClass.getName();
+            stepDocDTO.stepClassName = stepClassName;
+
+            String methodSignature = stepdoc.getMethodSignature();
+            stepDocDTO.stepMethodSignature = methodSignature;
+
+            StepMatcher stepMatcher = patternParser.parseStep(stepType, pattern);
+            StepPattern stepPattern = stepMatcher.pattern();
+            String resolvedPattern = stepPattern.resolved();
+            stepDocDTO.resolvedPattern = resolvedPattern;
+            setGroupedPatternOnStepDoc(stepDocDTO);
+
+            Method method = stepdoc.getMethod();
+            Type[] genericParameterTypes = method.getGenericParameterTypes();
+            Annotation[][] parametersAnnotations = method.getParameterAnnotations();
+            List<ParameterMetaInfo> parameterInfos = new ArrayList<ParameterMetaInfo>(genericParameterTypes.length);
+
+            for (int i = 0; i < genericParameterTypes.length; i++) {
+
+                Type genericParameterType = genericParameterTypes[i];
+
+                // find if annotated with ParameterInfo
+                Annotation[] parameterAnnotations = parametersAnnotations[i];
+                ParameterInfo paramInfoAnnotation = null;
+                for (int j = 0; j < parameterAnnotations.length; j++) {
+                    Annotation annotation = parameterAnnotations[j];
+                    if (ParameterInfo.class.isAssignableFrom(annotation.getClass())) {
+                        paramInfoAnnotation = (ParameterInfo) annotation;
+                        break;
-    }
+                    }
+                }
 
+                ParameterMetaInfo parameterInfo = new ParameterMetaInfo();
+                if (genericParameterType instanceof ParameterizedType) {
+                    ParameterizedType parameterizedType = (ParameterizedType) genericParameterType;
+                    Class<?> rawType = (Class<?>) parameterizedType.getRawType();
+                    if (rawType.getName().equals(List.class.getName())) {
+                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
+                        if (actualTypeArguments.length == 1) {
+                            Type actualTypeArgument = actualTypeArguments[0];
+                            if (actualTypeArgument instanceof Class<?>) {
+                                Class<?> classType = (Class<?>) actualTypeArgument;
+                                populateParameterInfo(parameterInfo, classType, paramInfoAnnotation);
+                                parameterInfo.listType = true;
+                            }
+                        } else {
+                            // if there are more type arguments, we ignore such cases
+                        }
+                    } else {
+                        // we ignore any other generic parameter types
+                    }
+                } else if (genericParameterType instanceof Class) {
+                    Class classType = (Class) genericParameterType;
+                    populateParameterInfo(parameterInfo, classType, paramInfoAnnotation);
+                } else {
+                    // we do not provide any meta information in this case
+                }
+                parameterInfos.add(parameterInfo);
+            }
+            stepDocDTO.parameterInfos = parameterInfos;
+
+            if (parameterInfos.size() != stepDocDTO.parameterGroups.size()) {
+                // this should not happen, but it may if the developer made a mistake in matching the number of method parameters to
+                // number of parameters in pattern
+                System.out.println("[WARN] Number of resolved parameters doesn't match number of gathered parameter infos, for class - "
+                        + stepDocDTO.stepClassName + " and method - " + stepDocDTO.stepMethodSignature);
+//                throw new IllegalStateException("Number of resolved parameters doesn't match number of gathered parameter infos");
+            }
+
+            List<Integer> parameterGroups = stepDocDTO.parameterGroups;
+            if (!parameterGroups.isEmpty()) {
+
+                // set parameter boundaries in pattern
+                String groupedRegExpPattern = stepDocDTO.groupedRegExpPattern;
+                Validate.notNull(groupedRegExpPattern);
+                Pattern groupedPattern = Pattern.compile(groupedRegExpPattern, Pattern.DOTALL);
+                Matcher matcher = groupedPattern.matcher(stepdoc.getPattern());
+                boolean matches = matcher.matches();
+                Validate.isTrue(matches, "Error - pattern should have matched");
+                List<Integer> parameterBoundaries = new ArrayList<Integer>(parameterGroups.size() * 2);
+                for (Integer parameterGroup : parameterGroups) {
+                    int groupStart = matcher.start(parameterGroup);
+                    parameterBoundaries.add(groupStart);
+                    int groupEnd = matcher.end(parameterGroup);
+                    parameterBoundaries.add(groupEnd);
+                }
+                stepDocDTO.paramBoundInPattern = parameterBoundaries;
+
+                // set extended pattern
+                int totalGroups = matcher.groupCount();
+                StringBuilder sb = new StringBuilder();
+                int paramGroupIndex = 0;
+                for (int i = 0; i < totalGroups; i++) {
+                    int groupNumber = i + 1;
+                    String groupText = matcher.group(groupNumber);
+                    if (parameterGroups.contains(groupNumber)) {
+                        // group is a parameter, check its parameter info
+                        ParameterMetaInfo parameterInfo = parameterInfos.get(paramGroupIndex);
+                        Validate.notNull(parameterInfo);
+                        List<TabularFieldMetaInfo> tabularFieldInfos = parameterInfo.tabularFieldInfos;
+                        if (tabularFieldInfos != null && !tabularFieldInfos.isEmpty()) {
+                            // replace the parameter name with parameter field names in tabular format
+                            int totalPipes = 0;
+                            sb.append("\n");
+                            sb.append("|");
+                            totalPipes++;
+                            for (TabularFieldMetaInfo tabularFieldInfo : tabularFieldInfos) {
+                                sb.append(tabularFieldInfo.fieldName);
+                                sb.append("|");
+                                totalPipes++;
+                            }
+                            sb.append("\n");
+                            // we add another line which contains same number of pipes as an empty values row, ready for user to fil in
+                            for (int j = 0; j < totalPipes; j++) {
+                                sb.append("|");
+                            }
+                            sb.append("\n");
+                        } else {
+                            sb.append(groupText);
+                        }
+                        paramGroupIndex++;
+                    } else {
+                        sb.append(groupText);
+                    }
+                }
+                String extendedPattern = sb.toString();
+                stepDocDTO.extendedPattern = extendedPattern;
+
+                // set extended pattern parameter boundaries
+                matcher = groupedPattern.matcher(extendedPattern);
+                matches = matcher.matches();
+                Validate.isTrue(matches, "Error - extended pattern should have matched");
+                List<Integer> extendedParameterBoundaries = new ArrayList<Integer>(parameterGroups.size() * 2);
+                for (Integer parameterGroup : parameterGroups) {
+                    int groupStart = matcher.start(parameterGroup);
+                    extendedParameterBoundaries.add(groupStart);
+                    int groupEnd = matcher.end(parameterGroup);
+                    extendedParameterBoundaries.add(groupEnd);
+                }
+                stepDocDTO.paramBoundInExtendPattern = extendedParameterBoundaries;
+
+            }
+
+            stepDocDTOs.add(stepDocDTO);
+        }
+
+        StepDocsPayload stepDocsPayload = new StepDocsPayload();
+        stepDocsPayload.stepDocs = stepDocDTOs;
+        uploadToJira(stepDocsPayload);
+    }
+
+    private void populateParameterInfo(ParameterMetaInfo parameterMetaInfo, Class classType, ParameterInfo paramInfoAnnotation) {
+
+        String parameterType = classType.getName();
+        parameterMetaInfo.parameterType = parameterType;
+        String simpleName = classType.getSimpleName();
+        parameterMetaInfo.simpleParameterType = simpleName;
+        Annotation asParamAnnotation = classType.getAnnotation(AsParameters.class);
+
+        if (asParamAnnotation != null) {
+            parameterMetaInfo.tabularFieldInfos = this.workoutTabularParameterInfos(classType);
+        } else {
+            this.populateSimpleParameterInfo(parameterMetaInfo, classType, paramInfoAnnotation);
+        }
+    }
+
+    private void populateSimpleParameterInfo(ParameterMetaInfo parameterMetaInfo, Class classType, ParameterInfo paramInfoAnnotation) {
+
+        // not a table type, but still may be a list type
+        // check if enum
+        if (classType.isEnum()) {
+            Object[] enumConstants = classType.getEnumConstants();
+            List<String> allowedvalues = new ArrayList<String>(enumConstants.length);
+            for (Object enumConstant : enumConstants) {
+                Enum e = (Enum) enumConstant;
+                allowedvalues.add(e.toString());
+            }
+            parameterMetaInfo.allowedValues = allowedvalues;
+        } else {
+            // not an enum so check for allowed or suggested values
+            if (paramInfoAnnotation != null) {
+                if (paramInfoAnnotation.allowedValues().length > 0) {
+                    List<String> allowedValues = Arrays.asList(paramInfoAnnotation.allowedValues());
+                    parameterMetaInfo.allowedValues = allowedValues;
+                } else if (paramInfoAnnotation.suggestedValuesEnum() != com.jbehaveforjira.javaclient.ParameterInfo.EmptyEnum.class) {
+                    Class susggestedValuesEnum = paramInfoAnnotation.suggestedValuesEnum();
+                    Object[] suggestedConstants = susggestedValuesEnum.getEnumConstants();
+                    List<String> suggestedValues = new ArrayList<String>();
+                    for (Object enumConstant : suggestedConstants) {
+                        Enum enumField = (Enum) enumConstant;
+                        String enumName = enumField.toString();
+                        suggestedValues.add(enumName);
+                    }
+                    parameterMetaInfo.suggestedValues = suggestedValues;
+                } else if (paramInfoAnnotation.suggestedValues().length > 0) {
+                    // suggested values are set
+                    List<String> suggestedValues = Arrays.asList(paramInfoAnnotation.suggestedValues());
+                    parameterMetaInfo.suggestedValues = suggestedValues;
+                }
+
+                // format
+                String pattern = paramInfoAnnotation.formatPattern();
+                if (!pattern.trim().isEmpty()) {
+                    parameterMetaInfo.formatPattern = pattern;
+                    String formatDisplayText = paramInfoAnnotation.formatDisplayText();
+                    if (!formatDisplayText.trim().isEmpty()) {
+                        parameterMetaInfo.formatDisplayText = formatDisplayText;
+                    }
+                }
+            }
+
+        }
+    }
+
+    private List<TabularFieldMetaInfo> workoutTabularParameterInfos(Class classType) {
+
+        List<TabularFieldMetaInfo> tabularFieldInfos = new ArrayList<TabularFieldMetaInfo>();
+
+        // parameter can be represented as a table
+        Field[] declaredFields = classType.getDeclaredFields();
+
+        for (Field declaredField : declaredFields) {
+
+            TabularFieldMetaInfo tabularFieldInfo = new TabularFieldMetaInfo();
+
+            // field name
+            Parameter fieldAnnotation = declaredField.getAnnotation(Parameter.class);
+            String fieldName;
+            if (fieldAnnotation != null) {
+                fieldName = fieldAnnotation.name();
+            } else {
+                fieldName = declaredField.getName();
+            }
+            tabularFieldInfo.fieldName = fieldName;
+
+            ParameterInfo parameterInfo = declaredField.getAnnotation(ParameterInfo.class);
+
+            // allowed field values, i.e. in case of enum
+            Class<?> fieldType = declaredField.getType();
+            Object[] enumConstants = fieldType.getEnumConstants();
+
+            if (fieldType == Boolean.class || fieldType == boolean.class) {
+                // boolean use case
+                List<String> allowedValues = new ArrayList<String>();
+                allowedValues.add("true");
+                allowedValues.add("false");
+                tabularFieldInfo.allowedValues = allowedValues;
+            } else if (enumConstants != null && enumConstants.length > 0) {
+                List<String> allowedValues = new ArrayList<String>();
+                Class<? extends Enum> enumFieldType = (Class<? extends Enum>) fieldType;
+                for (Object enumConstant : enumConstants) {
+                    Enum enumField = (Enum) enumConstant;
+                    String enumName = enumField.toString();
+                    allowedValues.add(enumName);
+                }
+
+                tabularFieldInfo.allowedValues = allowedValues;
+            } else {
+                // not an enum type or a boolean, so check for allowed values annotation
+                if (parameterInfo != null) {
+                    if (parameterInfo.allowedValues().length > 0) {
+                        List<String> allowedValues = Arrays.asList(parameterInfo.allowedValues());
+                        tabularFieldInfo.allowedValues = allowedValues;
+                    } else if (parameterInfo.suggestedValuesEnum() != com.jbehaveforjira.javaclient.ParameterInfo.EmptyEnum.class) {
+                        Class susggestedValuesEnum = parameterInfo.suggestedValuesEnum();
+                        Object[] suggestedConstants = susggestedValuesEnum.getEnumConstants();
+                        List<String> suggestedValues = new ArrayList<String>();
+                        for (Object enumConstant : suggestedConstants) {
+                            Enum enumField = (Enum) enumConstant;
+                            String enumName = enumField.toString();
+                            suggestedValues.add(enumName);
+                        }
+                        tabularFieldInfo.suggestedValues = suggestedValues;
+                    } else if (parameterInfo.suggestedValues().length > 0) {
+                        // suggested values are set
+                        List<String> suggestedValues = Arrays.asList(parameterInfo.suggestedValues());
+                        tabularFieldInfo.suggestedValues = suggestedValues;
+                    }
+                }
+
+            }
+
+            if (parameterInfo != null) {
+                // is mandatory
+                tabularFieldInfo.mandatory = parameterInfo.isMandatory();
+                // format
+                String pattern = parameterInfo.formatPattern();
+                if (!pattern.trim().isEmpty()) {
+                    tabularFieldInfo.formatPattern = pattern;
+                    String formatDisplayText = parameterInfo.formatDisplayText();
+                    if (!formatDisplayText.trim().isEmpty()) {
+                        tabularFieldInfo.formatDisplayText = formatDisplayText;
+                    }
+                }
+            }
+
+            tabularFieldInfos.add(tabularFieldInfo);
+        }
+
+        return tabularFieldInfos;
+    }
+
+    private void uploadToJira(StepDocsPayload stepDocsPayload) {
+
+        ObjectMapper mapper = new ObjectMapper();
+        String payloadAsString;
+        try {
+            payloadAsString = mapper.writeValueAsString(stepDocsPayload);
+        } catch (IOException e) {
+            throw new RuntimeException("Error occurred while trying to serialize object of type - "
+                    + StepDocsPayload.class.getName() + " to json.", e);
+        }
+
+        Client client = Client.create();
+        String response = client.resource(this.reportStepDocUrl)
+                .accept(MediaType.APPLICATION_JSON)
+                .type(MediaType.APPLICATION_JSON)
+                .post(String.class, payloadAsString);
+
+        if (!response.startsWith("success")) {
+            throw new RuntimeException("Failed to upload step doc! Server returned error message - " + response);
+        }
+    }
+
     @Override
     public void stepdocsMatching(String stepAsString, List<Stepdoc> matching, List<Object> stepsIntances) {
+        // ignored
+    }
 
-        this.stepdocReporter.stepdocsMatching(stepAsString, matching, stepsIntances);
+    private void setGroupedPatternOnStepDoc(StepDocDTO stepDocDTO) {
+
+        String resolvedPattern = stepDocDTO.resolvedPattern;
+        StringBuilder groupedPatternBuilder = new StringBuilder();
+        List<Integer> parameterGroups = new ArrayList<Integer>();
+
+        int pos = 0;
+        int groupCount = 0;
+
+        Pattern openBracePattern = Pattern.compile("(?<!\\\\)\\(");
+        Matcher openBraceMatcher = openBracePattern.matcher(resolvedPattern);
+        Pattern closeBracePattern = Pattern.compile("(?<!\\\\)\\)");
+        Matcher closeBraceMatcher = closeBracePattern.matcher(resolvedPattern);
+
+        boolean openBraceFound = openBraceMatcher.find(pos);
+        while (openBraceFound && pos < resolvedPattern.length()) {
+
+            // we want to group everything before that opening brace
+            groupedPatternBuilder.append("(");
+            groupedPatternBuilder.append(resolvedPattern.substring(pos, openBraceMatcher.start()));
+            groupedPatternBuilder.append(")");
+            groupCount++;
+
+            boolean closeBraceFound = closeBraceMatcher.find(openBraceMatcher.start());
+            Validate.isTrue(closeBraceFound, "Couldn't find closing matching brace in pattern - " + resolvedPattern);
+            groupedPatternBuilder.append(resolvedPattern.substring(openBraceMatcher.start(), closeBraceMatcher.end()));
+            groupCount++;
+            parameterGroups.add(groupCount);
+
+            pos = closeBraceMatcher.end();
+
+            openBraceFound = openBraceMatcher.find(pos);
-    }
+        }
 
+        // there are no more parameter groups so we simply append any string into last group
+        if (pos < resolvedPattern.length()) {
+            groupedPatternBuilder.append("(");
+            groupedPatternBuilder.append(resolvedPattern.substring(pos));
+            groupedPatternBuilder.append(")");
-}
+        }
+
+        String groupedPattern = groupedPatternBuilder.toString();
+        if (groupedPattern.isEmpty()) {
+            // reg exp pattern did not contain any groups
+            groupedPattern = "(" + resolvedPattern + ")";
+        }
+        stepDocDTO.groupedRegExpPattern = groupedPattern;
+        stepDocDTO.parameterGroups = parameterGroups;
+    }
+
+    @XmlRootElement
+    @XmlAccessorType(XmlAccessType.FIELD)
+    private class TabularFieldMetaInfo {
+
+        public String fieldName;
+
+        public boolean mandatory;
+
+        public List<String> allowedValues;
+
+        public List<String> suggestedValues;
+
+        public String formatPattern;
+
+        public String formatDisplayText;
+    }
+
+    @XmlRootElement
+    @XmlAccessorType(XmlAccessType.FIELD)
+    private class ParameterMetaInfo {
+
+        public String parameterType;
+
+        public String simpleParameterType;
+
+        public boolean listType;
+
+        public List<String> allowedValues;
+
+        public List<String> suggestedValues;
+
+        public String formatPattern;
+
+        public String formatDisplayText;
+
+        public List<TabularFieldMetaInfo> tabularFieldInfos;
+    }
+
+    @XmlRootElement
+    @XmlAccessorType(XmlAccessType.FIELD)
+    private class StepDocDTO {
+
+        public String startingWord;
+
+        public String pattern;
+
+        public List<Integer> paramBoundInPattern;
+
+        public String extendedPattern;
+
+        public List<Integer> paramBoundInExtendPattern;
+
+        public String resolvedPattern;
+
+        public String groupedRegExpPattern;
+
+        public String stepClassName;
+
+        public String stepMethodSignature;
+
+        public List<Integer> parameterGroups = new ArrayList<Integer>();
+
+        public List<ParameterMetaInfo> parameterInfos = new ArrayList<ParameterMetaInfo>();
+    }
+
+    @XmlRootElement
+    @XmlAccessorType(XmlAccessType.FIELD)
+    private static class StepDocsPayload {
+
+        public List<StepDocDTO> stepDocs;
+    }
+}
+
+
+
+
+
Index: jbehave-for-jira/jbehave-for-jira-java-client/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/pom.xml	(date 1413310697000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/pom.xml	(revision )
@@ -28,80 +28,156 @@
             <email>m.pristrom@gmail.com</email>
         </developer>
     </developers>
-    <distributionManagement>
-        <downloadUrl>http://java.sun.com/products/javabeans/glasgow/jaf.html</downloadUrl>
-        <snapshotRepository>
-            <id>ossrh</id>
-            <url>https://oss.sonatype.org/content/repositories/snapshots</url>
-        </snapshotRepository>
-        <repository>
-            <id>ossrh</id>
-            <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>
-        </repository>
-    </distributionManagement>
-    <!--<build>-->
-        <!--<plugins>-->
+    <!--<distributionManagement>-->
+    <!--<downloadUrl>http://java.sun.com/products/javabeans/glasgow/jaf.html</downloadUrl>-->
+    <!--<snapshotRepository>-->
+    <!--<id>ossrh</id>-->
+    <!--<url>https://oss.sonatype.org/content/repositories/snapshots</url>-->
+    <!--</snapshotRepository>-->
+    <!--<repository>-->
+    <!--<id>ossrh</id>-->
+    <!--<url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>-->
+    <!--</repository>-->
+    <!--</distributionManagement>-->
+    <profiles>
+        <profile>
+            <id>release</id>
+            <activation>
+                <activeByDefault>false</activeByDefault>
+            </activation>
+            <build>
+                <plugins>
+                    <plugin>
+                        <groupId>com.github.wvengen</groupId>
+                        <artifactId>proguard-maven-plugin</artifactId>
+                        <version>2.0.6</version>
+                        <dependencies>
+                            <dependency>
+                                <groupId>net.sf.proguard</groupId>
+                                <artifactId>proguard-base</artifactId>
+                                <version>4.10</version>
+                            </dependency>
+                        </dependencies>
+                        <executions>
+                            <execution>
+                                <phase>package</phase>
+                                <goals>
+                                    <goal>proguard</goal>
+                                </goals>
+                            </execution>
+                        </executions>
+                        <configuration>
+                            <proguardVersion>4.10</proguardVersion>
+                            <options>
+                                <!--keep all public enums-->
+                                <option>-printmapping proguard_mapping.map</option>
+                                <!--<option>-keepparameternames</option>-->
+                                <option>-renamesourcefileattribute SourceFile</option>
+                                <option>
+                                    -keepattributes Exceptions,InnerClasses,Signature,Deprecated,
+                                    SourceFile,LineNumberTable,*Annotation*,EnclosingMethod
+                                </option>
+                                <option>
+                                    -keepclassmembers enum * {
+                                    *;
+                                    }
+                                </option>
+                                <!--keep all public members of public classes-->
+                                <option>-keep
+                                    public class * {
+                                    public *;
+                                    }
+                                </option>
+                                <!--keep all protected members of public classes-->
+                                <option>-keep
+                                    public class * {
+                                    protected *;
+                                    }
+                                </option>
+                                <!--<option>-keep-->
+                                <!--class * {-->
+                                <!--public *;-->
+                                <!--}-->
+                                <!--</option>-->
+                                <option>-adaptresourcefilecontents **.xml</option>
+                                <!--<option>-keepattributes *Annotation*</option>-->
+                                <!--<option>-keepattributes EnclosingMethod</option>-->
+                                <option>-dontshrink</option>
+                                <option>-dontoptimize</option>
+                                <option>-dontpreverify</option>
+                                <!--<option>-printmapping</option>-->
+                                <!--<option>-keepattributes Signature</option>-->
+                            </options>
+                            <libs>
+                                <lib>${java.home}/lib/rt.jar</lib>
+                                <lib>${java.home}/lib/jce.jar</lib>
+                            </libs>
+                        </configuration>
+                    </plugin>
-            <!--<plugin>-->
-                <!--<groupId>org.apache.maven.plugins</groupId>-->
-                <!--<artifactId>maven-source-plugin</artifactId>-->
-                <!--<executions>-->
+                    <!--<plugin>-->
+                    <!--<groupId>org.apache.maven.plugins</groupId>-->
+                    <!--<artifactId>maven-source-plugin</artifactId>-->
+                    <!--<executions>-->
                     <!--<execution>-->
-                        <!--<id>attach-sources</id>-->
-                        <!--<goals>-->
-                            <!--<goal>jar</goal>-->
-                        <!--</goals>-->
+                    <!--<id>attach-sources</id>-->
+                    <!--<goals>-->
+                    <!--<goal>jar</goal>-->
+                    <!--</goals>-->
                     <!--</execution>-->
-                <!--</executions>-->
-            <!--</plugin>-->
-            <!--<plugin>-->
-                <!--<groupId>org.apache.maven.plugins</groupId>-->
-                <!--<artifactId>maven-javadoc-plugin</artifactId>-->
-                <!--<executions>-->
+                    <!--</executions>-->
+                    <!--</plugin>-->
+                    <!--<plugin>-->
+                    <!--<groupId>org.apache.maven.plugins</groupId>-->
+                    <!--<artifactId>maven-javadoc-plugin</artifactId>-->
+                    <!--<executions>-->
                     <!--<execution>-->
-                        <!--<id>attach-javadocs</id>-->
-                        <!--<goals>-->
-                            <!--<goal>jar</goal>-->
-                        <!--</goals>-->
+                    <!--<id>attach-javadocs</id>-->
+                    <!--<goals>-->
+                    <!--<goal>jar</goal>-->
+                    <!--</goals>-->
                     <!--</execution>-->
-                <!--</executions>-->
-            <!--</plugin>-->
-            <!--<plugin>-->
-                <!--<groupId>org.apache.maven.plugins</groupId>-->
-                <!--<artifactId>maven-gpg-plugin</artifactId>-->
-                <!--<version>1.5</version>-->
-                <!--<executions>-->
+                    <!--</executions>-->
+                    <!--</plugin>-->
+                    <!--<plugin>-->
+                    <!--<groupId>org.apache.maven.plugins</groupId>-->
+                    <!--<artifactId>maven-gpg-plugin</artifactId>-->
+                    <!--<version>1.5</version>-->
+                    <!--<executions>-->
                     <!--<execution>-->
-                        <!--<id>sign-artifacts</id>-->
-                        <!--<phase>verify</phase>-->
-                        <!--<goals>-->
-                            <!--<goal>sign</goal>-->
-                        <!--</goals>-->
+                    <!--<id>sign-artifacts</id>-->
+                    <!--<phase>verify</phase>-->
+                    <!--<goals>-->
+                    <!--<goal>sign</goal>-->
+                    <!--</goals>-->
                     <!--</execution>-->
-                <!--</executions>-->
-            <!--</plugin>-->
-            <!--<plugin>-->
-                <!--<groupId>org.sonatype.plugins</groupId>-->
-                <!--<artifactId>nexus-staging-maven-plugin</artifactId>-->
-                <!--<version>1.6.2</version>-->
-                <!--<extensions>true</extensions>-->
-                <!--<configuration>-->
+                    <!--</executions>-->
+                    <!--</plugin>-->
+                    <!--<plugin>-->
+                    <!--<groupId>org.sonatype.plugins</groupId>-->
+                    <!--<artifactId>nexus-staging-maven-plugin</artifactId>-->
+                    <!--<version>1.6.2</version>-->
+                    <!--<extensions>true</extensions>-->
+                    <!--<configuration>-->
                     <!--<serverId>ossrh</serverId>-->
                     <!--<nexusUrl>https://oss.sonatype.org/</nexusUrl>-->
                     <!--<autoReleaseAfterClose>true</autoReleaseAfterClose>-->
-                <!--</configuration>-->
-            <!--</plugin>-->
+                    <!--</configuration>-->
+                    <!--</plugin>-->
-        <!--</plugins>-->
-    <!--</build>-->
+                </plugins>
+            </build>
+        </profile>
+    </profiles>
     <dependencies>
+        <!--<dependency>-->
+        <!--<groupId>org.codehaus.groovy</groupId>-->
+        <!--<artifactId>groovy-all</artifactId>-->
+        <!--<version>2.3.6</version>-->
+        <!--</dependency>-->
         <dependency>
-            <groupId>org.codehaus.groovy</groupId>
-            <artifactId>groovy-all</artifactId>
-            <version>2.3.6</version>
-        </dependency>
-        <dependency>
             <groupId>org.jbehave</groupId>
             <artifactId>jbehave-core</artifactId>
             <version>3.9.5</version>
+            <scope>provided</scope>
         </dependency>
         <dependency>
             <groupId>com.sun.jersey</groupId>
\ No newline at end of file
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryPathsFinder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryPathsFinder.java	(date 1413310697000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryPathsFinder.java	(revision )
@@ -1,5 +1,17 @@
 package com.jbehaveforjira.javaclient;
 
+import com.sun.jersey.api.client.Client;
+import com.sun.jersey.api.client.ClientResponse;
+import com.sun.jersey.api.client.WebResource;
+
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.xml.bind.annotation.XmlAccessType;
+import javax.xml.bind.annotation.XmlAccessorType;
+import javax.xml.bind.annotation.XmlRootElement;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
@@ -8,27 +20,65 @@
  */
 public class JiraStoryPathsFinder implements StoryPathsFinder {
 
-    private final StoryPathsFinder storyPathsFinder;
+    private String postUrl;
 
-    public JiraStoryPathsFinder(String jiraBaseUrl, String jiraProject, String jiraUserName, String jiraPassword) {
+    public JiraStoryPathsFinder(String jiraBaseUrl, String projectKey, String username, String password) {
 
-        String[] constructorArgs = {jiraBaseUrl, jiraProject, jiraUserName, jiraPassword};
-        this.storyPathsFinder = GroovyResourceHelper.loadGroovyResource(
-                jiraBaseUrl, "story-paths-finder", jiraUserName, jiraPassword,
-                "StoryPathsFinder", constructorArgs);
+        this.postUrl = jiraBaseUrl + "/rest/jbehave-for-jira/1.0/find/story-paths/" + projectKey + "?os_username=" + username + "&os_password=" + password;
     }
 
-    @Override
     public List<String> findPaths() {
-
         return this.findPaths(Collections.EMPTY_LIST, Collections.EMPTY_LIST);
     }
 
-    @Override
     public List<String> findPaths(List<String> includes, List<String> excludes) {
 
-        List<String> paths = storyPathsFinder.findPaths(includes, excludes);
+        List<String> paths = new ArrayList<String>();
+
+        URI jiraSearchUrl = null;
+        try {
+            jiraSearchUrl = new URI(postUrl);
+        } catch (URISyntaxException e) {
+            throw new RuntimeException(e);
+        }
+
+        Client client = Client.create();
+        WebResource res = client.resource(jiraSearchUrl);
+        res.type(MediaType.APPLICATION_JSON);
+        ClientResponse response = res.get(ClientResponse.class);
+        if (response.getStatus() == 200) {
+
+            int length = response.getLength();
+            MediaType type = response.getType();
+            StoryPaths storyPaths = response.getEntity(StoryPaths.class);
+
+            if (storyPaths.getPaths() != null && !storyPaths.getPaths().isEmpty()) {
+                paths = storyPaths.getPaths();
+            }
+
+        } else {
+            int status = response.getStatus();
+            Response.StatusType statusInfo = response.getStatusInfo();
+            throw new RuntimeException("Error occurred while trying to find Jira story paths. " +
+                    "Response status was - " + status + ", status info - " + statusInfo);
+        }
+
         return paths;
+    }
+
+    @XmlRootElement
+    @XmlAccessorType(XmlAccessType.FIELD)
+    public static class StoryPaths {
+
+        private List<String> paths;
+
+        public List<String> getPaths() {
+            return paths;
+        }
+
+        public void setPaths(List<String> paths) {
+            this.paths = paths;
+        }
     }
 
-}
+}
\ No newline at end of file
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/GroovyResourceHelper.java
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/GroovyResourceHelper.java	(date 1413310697000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/GroovyResourceHelper.java	(date 1413310697000)
@@ -1,81 +0,0 @@
-package com.jbehaveforjira.javaclient;
-
-import com.sun.jersey.api.client.Client;
-import com.sun.jersey.api.client.ClientResponse;
-import groovy.lang.GroovyClassLoader;
-
-import javax.ws.rs.core.MediaType;
-import javax.ws.rs.core.Response;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.net.URI;
-import java.net.URISyntaxException;
-
-/**
- * @author Maryna Pristrom
- */
-class GroovyResourceHelper {
-
-    private static String baseRestResPath = "/rest/jbehave-for-jira/1.0/groovy-client/";
-
-    public static <T> T loadGroovyResource(String jiraUrl, String resourcePath,
-                                           String username, String password, String className, Object[] constructorArgs) {
-        return loadGroovyResource(jiraUrl, baseRestResPath, resourcePath, username, password, className, constructorArgs
-        );
-    }
-
-    private static <T> T loadGroovyResource(String jiraUrl, String restResBasePath, String resourcePath,
-                                           String username, String password, String className, Object[] constructorArgs) {
-
-        URI jiraSearchUrl = null;
-        try {
-            String fullPath = jiraUrl + restResBasePath + resourcePath;
-            fullPath += "?os_username=" + username + "&os_password=" + password;
-            jiraSearchUrl = new URI(fullPath);
-        } catch (URISyntaxException e) {
-            throw new RuntimeException(e);
-        }
-
-        Client client = Client.create();
-        ClientResponse response = client
-                .resource(jiraSearchUrl)
-                .type(MediaType.APPLICATION_JSON)
-                .get(ClientResponse.class);
-        if (response.getStatus() != 200) {
-
-            int status = response.getStatus();
-            Response.StatusType statusInfo = response.getStatusInfo();
-            throw new RuntimeException("Error occurred while trying to load groovy resource from Jira. " +
-                    "Response status was - " + status + ", status info - " + statusInfo);
-
-        } else {
-            String resString = response.getEntity(String.class);
-
-            GroovyClassLoader gcl = new GroovyClassLoader();
-            Class clazz = gcl.parseClass(resString, className);
-            Object instance = null;
-            try {
-
-                Class<?>[] argTypes = new Class<?>[constructorArgs.length];
-                for (int i = 0; i < constructorArgs.length; i++) {
-                    Object constructorArg = constructorArgs[i];
-                    Class<?> argType = constructorArg.getClass();
-                    argTypes[i] = argType;
-                }
-                Constructor constructor = clazz.getConstructor(argTypes);
-                instance = constructor.newInstance(constructorArgs);
-            } catch (InstantiationException e) {
-                throw new RuntimeException(e);
-            } catch (IllegalAccessException e) {
-                throw new RuntimeException(e);
-            } catch (NoSuchMethodException e) {
-                throw new RuntimeException(e);
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException(e);
-            }
-            T typedInstance = (T) instance;
-            return typedInstance;
-        }
-    }
-
-}
