Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterListConverter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterListConverter.java	(revision )
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterListConverter.java	(revision )
@@ -0,0 +1,68 @@
+package com.jbehaveforjira.javaclient.utils;
+
+import org.jbehave.core.steps.ParameterConverters;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.List;
+
+import static java.util.Arrays.asList;
+
+/**
+ * Custom converter for any types that implement StepParameter interface
+ *
+ * @author Maryna Pristrom
+ */
+public class StepParameterListConverter implements ParameterConverters.ParameterConverter {
+
+    private final StepParameterConverter stepParamConverter;
+
+    private String valueSeparator;
+
+    public StepParameterListConverter() {
+        this(",");
+    }
+
+    public StepParameterListConverter(String valueSeparator) {
+        this.stepParamConverter = new StepParameterConverter();
+        this.valueSeparator = valueSeparator;
+    }
+
+    @Override
+    public boolean accept(Type type) {
+        if (type instanceof ParameterizedType) {
+            Type rawType = rawType(type);
+            Type argumentType = argumentType(type);
+            return List.class.isAssignableFrom((Class<?>) rawType) && stepParamConverter.accept(argumentType);
+        }
+        return false;
+    }
+
+    @Override
+    public Object convertValue(String value, Type type) {
+        Type argumentType = argumentType(type);
+        List<String> values = trim(asList(value.split(valueSeparator)));
+        List<Object> typedValues = new ArrayList<Object>();
+        for (String string : values) {
+            typedValues.add(stepParamConverter.convertValue(string, argumentType));
+        }
+        return typedValues;
+    }
+
+    private Type rawType(Type type) {
+        return ((ParameterizedType) type).getRawType();
+    }
+
+    private Type argumentType(Type type) {
+        return ((ParameterizedType) type).getActualTypeArguments()[0];
+    }
+
+    private static List<String> trim(List<String> values) {
+        List<String> trimmed = new ArrayList<String>();
+        for (String value : values) {
+            trimmed.add(value.trim());
+        }
+        return trimmed;
+    }
+}
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterConversionException.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterConversionException.java	(revision )
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterConversionException.java	(revision )
@@ -0,0 +1,28 @@
+package com.jbehaveforjira.javaclient.utils;
+
+/**
+ * Specialized sub type of RuntimeException for throwing when an error occurs during step parameter conversion.
+ *
+ * @author Maryna Pristrom
+ */
+public class StepParameterConversionException extends RuntimeException {
+
+    public StepParameterConversionException() {
+    }
+
+    public StepParameterConversionException(String message) {
+        super(message);
+    }
+
+    public StepParameterConversionException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public StepParameterConversionException(Throwable cause) {
+        super(cause);
+    }
+
+    public StepParameterConversionException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
+        super(message, cause, enableSuppression, writableStackTrace);
+    }
+}
\ No newline at end of file
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryLoader.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryLoader.java	(date 1414057529000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryLoader.java	(revision )
@@ -15,6 +15,8 @@
 import java.io.PrintWriter;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /**
  * @author Maryna Pristrom
@@ -31,15 +33,20 @@
 
     private String password;
 
-    private String downloadedStoriesDir = "src/test/resources/jira_stories";
+    private String downloadedStoriesDir;
 
     private String loadStoryPath = "rest/jbehave-for-jira/1.0/find/for-path/";
 
     public JiraStoryLoader(String jiraBaseUrl, String projectKey, String username, String password) {
+        this(jiraBaseUrl, projectKey, username, password, null);
+    }
+
+    public JiraStoryLoader(String jiraBaseUrl, String projectKey, String username, String password, String downloadDir) {
         this.jiraBaseUrl = jiraBaseUrl;
         this.projectKey = projectKey;
         this.username = username;
         this.password = password;
+        this.downloadedStoriesDir = downloadDir;
     }
 
     @Override
@@ -65,6 +72,11 @@
 
         if (response.getStatus() == 200) {
             String story = response.getEntity(String.class);
+
+            if (downloadedStoriesDir != null && !downloadedStoriesDir.trim().isEmpty()) {
+                this.writeModelToFile(storyPath, story);
+            }
+
             return story;
         } else {
             int status = response.getStatus();
@@ -77,10 +89,29 @@
 
     private void writeModelToFile(String storyPath, String storyModel) {
 
+        // trim story version from story path
+        // extract version
+        String actualStoryPath;
+        String regexPattern = "(.*)\\.([0-9]*)(\\.story)";
+        Pattern p = Pattern.compile(regexPattern);
+        Matcher matcher = p.matcher(storyPath);
+        if (matcher.matches()) {
+            actualStoryPath = matcher.group(1) + matcher.group(3);
+        } else {
+            throw new IllegalArgumentException("Jira story path must match pattern - " + regexPattern);
+        }
+
         PrintWriter pw = null;
         try {
             File storiesDir = new File(downloadedStoriesDir);
-            File outFile = new File(storiesDir, storyPath);
+            if (storiesDir.exists()) {
+                if (!storiesDir.isDirectory()) {
+                    throw new RuntimeException("Specified download directory must not be an existing file!");
+                }
+            } else {
+                storiesDir.mkdirs();
+            }
+            File outFile = new File(storiesDir, actualStoryPath);
             outFile.getParentFile().mkdirs();
             FileWriter fw = new FileWriter(outFile.getAbsoluteFile());
             pw = new PrintWriter(fw);
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryReporter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryReporter.java	(date 1414057529000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/JiraStoryReporter.java	(revision )
@@ -41,8 +41,10 @@
 
         not_performed,
 
-        ignored
+        ignored,
 
+        comment
+
     }
 
     private String basePostPath;
@@ -58,12 +60,12 @@
     private String environment;
 
     public JiraStoryReporter(File file, Keywords keywords,
-                                       String jiraBaseUrl, String jiraProject, String username, String password, String environment) {
+                             String jiraBaseUrl, String jiraProject, String username, String password, String environment) {
-        this(file, keywords, new FreemarkerProcessor(), "ftl/jbehave-html-output.ftl", jiraBaseUrl, jiraProject, username, password, environment);
+        this(file, keywords, new FreemarkerProcessor(), "ftl/jira-jbehave-html-output.ftl", jiraBaseUrl, jiraProject, username, password, environment);
     }
 
     public JiraStoryReporter(File file, Keywords keywords, TemplateProcessor processor, String templatePath,
-                                       String jiraBaseUrl, String jiraProject, String username, String password, String environment) {
+                             String jiraBaseUrl, String jiraProject, String username, String password, String environment) {
         this.file = file;
         this.keywords = keywords;
         this.processor = processor;
@@ -643,7 +645,7 @@
 
             AfterScenario.Outcome[] outcomes = AfterScenario.Outcome.values();
             List<String> strOutcomes = new ArrayList<String>(outcomes.length);
-            for (AfterScenario.Outcome outcome : outcomes ) {
+            for (AfterScenario.Outcome outcome : outcomes) {
                 strOutcomes.add(outcome.name());
             }
             return strOutcomes;
@@ -767,67 +769,76 @@
 
             stepTokens = new ArrayList<OutputStepToken>();
 
+            // check for comment line
+            if (step.startsWith("!--") && outcome == TestStatus.ignored) {
+
+                // add comment line
+                stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.COMMENT, step));
+                this.outcome = TestStatus.comment;
+
+            } else {
+
-            int indexOfFirstSpace = step.indexOf(" ");
-            Validate.isTrue(indexOfFirstSpace > -1);
+                int indexOfFirstSpace = step.indexOf(" ");
+                Validate.isTrue(indexOfFirstSpace > -1);
 
-            String keyword = step.substring(0, indexOfFirstSpace);
-            stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.KEYWORD, keyword));
+                String keyword = step.substring(0, indexOfFirstSpace);
+                stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.KEYWORD, keyword));
 
-            String stepBody = step.substring(indexOfFirstSpace);
-            stepBody = remarkBody(stepBody);
+                String stepBody = step.substring(indexOfFirstSpace);
+                stepBody = remarkBody(stepBody);
 
-            // find any parameter markers
-            Pattern simpleParamPattern = Pattern.compile(
-                    "(.*?)"
-                            // have to use '+' quantifier as parameterized steps are marked with invisible markers two times
-                            + "((\\" + StepCreator.PARAMETER_VALUE_START + ")+)"
-                            + "(.*?)"
-                            + "((\\" + StepCreator.PARAMETER_VALUE_END + ")+)"
-                            + "(.*)"
-                    , Pattern.DOTALL
-            );
-            Pattern tableParamPattern = Pattern.compile(
-                    "(.*?)"
-                            + "(\\" + StepCreator.PARAMETER_TABLE_START + ")"
-                            + "(.*?)"
-                            + "(\\" + StepCreator.PARAMETER_TABLE_END + ")"
-                            + "(.*)"
-                    , Pattern.DOTALL
-            );
-            int pos = 0;
-            Matcher simpleParamMatcher = simpleParamPattern.matcher(stepBody);
-            Matcher tableParamMatcher = tableParamPattern.matcher(stepBody);
-            while (pos < stepBody.length()) {
+                // find any parameter markers
+                Pattern simpleParamPattern = Pattern.compile(
+                        "(.*?)"
+                                // have to use '+' quantifier as parameterized steps are marked with invisible markers two times
+                                + "((\\" + StepCreator.PARAMETER_VALUE_START + ")+)"
+                                + "(.*?)"
+                                + "((\\" + StepCreator.PARAMETER_VALUE_END + ")+)"
+                                + "(.*)"
+                        , Pattern.DOTALL
+                );
+                Pattern tableParamPattern = Pattern.compile(
+                        "(.*?)"
+                                + "(\\" + StepCreator.PARAMETER_TABLE_START + ")"
+                                + "(.*?)"
+                                + "(\\" + StepCreator.PARAMETER_TABLE_END + ")"
+                                + "(.*)"
+                        , Pattern.DOTALL
+                );
+                int pos = 0;
+                Matcher simpleParamMatcher = simpleParamPattern.matcher(stepBody);
+                Matcher tableParamMatcher = tableParamPattern.matcher(stepBody);
+                while (pos < stepBody.length()) {
 
-                if (simpleParamMatcher.find(pos)) {
-                    // simple parameter
-                    String beforeParam = simpleParamMatcher.group(1);
-                    if (beforeParam != null) {
-                        stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, beforeParam));
-                    }
-                    String paramValue = simpleParamMatcher.group(4);
-                    stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.PARAMETER, paramValue));
-                    pos = simpleParamMatcher.end(5);
-                } else if (tableParamMatcher.find(pos)) {
-                    // tabular parameter
-                    String beforeParam = tableParamMatcher.group(1);
-                    if (beforeParam != null) {
-                        stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, beforeParam));
-                    }
-                    String paramValue = tableParamMatcher.group(3);
-                    stepTokens.add(new TabularParameterStepToken(paramValue));
-                    pos = tableParamMatcher.end(4);
-                } else {
-                    // no marked parameters left
-                    String remainingText = stepBody.substring(pos);
-                    stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, remainingText));
-                    pos = stepBody.length();
-                }
+                    if (simpleParamMatcher.find(pos)) {
+                        // simple parameter
+                        String beforeParam = simpleParamMatcher.group(1);
+                        if (beforeParam != null) {
+                            stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, beforeParam));
+                        }
+                        String paramValue = simpleParamMatcher.group(4);
+                        stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.PARAMETER, paramValue));
+                        pos = simpleParamMatcher.end(5);
+                    } else if (tableParamMatcher.find(pos)) {
+                        // tabular parameter
+                        String beforeParam = tableParamMatcher.group(1);
+                        if (beforeParam != null) {
+                            stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, beforeParam));
+                        }
+                        String paramValue = tableParamMatcher.group(3);
+                        stepTokens.add(new TabularParameterStepToken(paramValue));
+                        pos = tableParamMatcher.end(4);
+                    } else {
+                        // no marked parameters left
+                        String remainingText = stepBody.substring(pos);
+                        stepTokens.add(new OutputStepToken(OutputStepToken.StepTokenType.TEXT, remainingText));
+                        pos = stepBody.length();
+                    }
 
-            }
+                }
 
-
-        }
+            }
+        }
 
         public String getStep() {
             return step;
@@ -986,7 +997,8 @@
             KEYWORD,
             TEXT,
             PARAMETER,
-            TABULAR_PARAMETER
+            TABULAR_PARAMETER,
+            COMMENT
         }
 
         private StepTokenType type;
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterConverter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterConverter.java	(revision )
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameterConverter.java	(revision )
@@ -0,0 +1,62 @@
+package com.jbehaveforjira.javaclient.utils;
+
+import org.jbehave.core.steps.ParameterConverters;
+
+import java.lang.reflect.Type;
+
+/**
+ * Custom converter for any types that implement StepParameter interface
+ *
+ * @author Maryna Pristrom
+ */
+public class StepParameterConverter implements ParameterConverters.ParameterConverter {
+
+    @Override
+    public boolean accept(Type type) {
+        if (type instanceof Class<?>) {
+            Class<?> clazz = (Class<?>) type;
+            return StepParameter.class.isAssignableFrom(clazz);
+        }
+        return false;
+    }
+
+    @Override
+    public Object convertValue(String value, Type type) {
+
+        Class<?> clazz = (Class<?>) type;
+
+        if (clazz.isEnum()) {
+
+            // we handle enum types slightly differently as the implementation inside individual enum constants
+            // should normally throw an exception if a given enum constant doesn't match the specified value. We need to try all enum
+            // constants before actually failing conversion.
+            Object[] enumConstants = clazz.getEnumConstants();
+            String[] allowedValues = new String[enumConstants.length];
+            for (int i = 0; i < enumConstants.length; i++) {
+                Object enumConstant = enumConstants[i];
+                StepParameter toFromEnum = (StepParameter) enumConstant;
+                try {
+                    toFromEnum.fromString(value);
+                    return toFromEnum;
+                } catch (RuntimeException e) {
+                    // ignore;
+                    allowedValues[i] = toFromEnum.asString();
+                }
+            }
+            throw new IllegalArgumentException("Failed to convert step parameter value - '" + value + "' into enum of type - " + clazz.getSimpleName()
+                    + ". Allowed values are: " + allowedValues);
+        } else {
+            try {
+                StepParameter newInstance = (StepParameter) clazz.newInstance();
+                newInstance.fromString(value);
+                return newInstance;
+            } catch (InstantiationException e) {
+                throw new StepParameterConversionException("Failed to convert step parameter string value - '" + value + "' into instance of type - "
+                        + clazz.getSimpleName(), e);
+            } catch (IllegalAccessException e) {
+                throw new StepParameterConversionException("Failed to convert step parameter string value - '" + value + "' into instance of type - "
+                        + clazz.getSimpleName(), e);
+            }
+        }
+    }
+}
\ No newline at end of file
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/resources/ftl/jbehave-html-output.ftl
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/resources/ftl/jbehave-html-output.ftl	(date 1414057529000)
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/resources/ftl/jira-jbehave-html-output.ftl	(revision )
@@ -141,7 +141,9 @@
 <#--${formattedStep}-->
 
     <#list step.getStepTokens() as token>
-        <#if token.getType() == "KEYWORD">
+        <#if token.getType() == "COMMENT">
+            <span class="comment">${token.asString()?html}</span>
+        <#elseif token.getType() == "KEYWORD">
 			<span class="keyword">${token.asString()?html}</span>
         <#elseif token.getType() == "TEXT">
 			<span class="text">${token.asString()?html}</span>
\ No newline at end of file
Index: jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameter.java	(revision )
+++ jbehave-for-jira/jbehave-for-jira-java-client/src/main/java/com/jbehaveforjira/javaclient/utils/StepParameter.java	(revision )
@@ -0,0 +1,19 @@
+package com.jbehaveforjira.javaclient.utils;
+
+/**
+ * @author Maryna Pristrom
+ */
+public interface StepParameter {
+
+    /**
+     * Converts current instance into string representation.
+     * @return
+     */
+    String asString();
+
+    /**
+     * Populates given instance from the specified string representation.
+     * @param asString
+     */
+    void fromString(String asString);
+}
\ No newline at end of file
