Index: jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/js/StoryController.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/js/StoryController.js	(date 1411760883000)
+++ jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/js/StoryController.js	(revision )
@@ -183,7 +183,7 @@
 
         debug("> reshowStory");
 
-        if (initialized) {
+        if (initialized && document.getElementById("jbStoryTextArea") != null) {
 
             editor = storyController.initEditor();
 
@@ -769,7 +769,7 @@
     function TextUtils() {
 
         this.startsWithExamples = function (text) {
-            var regExpPattern = new RegExp("^(Examples:)");
+            var regExpPattern = /^(Examples:)/;
             var matchedResult = regExpPattern.exec(text);
             if (matchedResult != null) {
                 return true;
@@ -779,31 +779,31 @@
         }
 
         this.startsWithScenario = function (text) {
-            var regExpPattern = new RegExp("^(Scenario:)\\s");
+            var regExpPattern = /^(Scenario:)\s/;
             var matchedResult = regExpPattern.exec(text);
             return matchedResult != null;
         }
 
         this.startsWithAfter = function (text) {
-            var regExpPattern = new RegExp("^(After:)");
+            var regExpPattern = /^(After:)/;
             var matchedResult = regExpPattern.exec(text);
             return matchedResult != null;
         }
 
         this.startsWithOutcome = function (text) {
-            var regExpPattern = new RegExp("^(Outcome:)\\s");
+            var regExpPattern = /^(Outcome:)\s/;
             var matchedResult = regExpPattern.exec(text);
             return matchedResult != null;
         }
 
         this.startsWithGivenWhenThen = function (text) {
-            var regExpPattern = new RegExp("^(Given|When|Then)\\s");
+            var regExpPattern = /^(Given|When|Then)\s/;
             var matchedResult = regExpPattern.exec(text);
             return matchedResult != null;
         }
 
         this.startsWithAnd = function (text) {
-            var regExpPattern = new RegExp("^(And)\\s");
+            var regExpPattern = /^(And)\s/;
             var matchedResult = regExpPattern.exec(text);
             return matchedResult != null;
         }
@@ -819,18 +819,18 @@
         }
     }
 
-    this.addModeGutterError = function(from, to, message) {
-        errorsGutter.addModeError(from, to, message);
-    }
+//    this.addModeGutterError = function (from, to, message) {
+//        errorsGutter.addModeError(from, to, message);
+//    }
+//
+//    this.addModeGutterWarning = function (from, to, message) {
+//        errorsGutter.addModeWarning(from, to, message);
+//    }
+//
+//    this.clearModeGutterErrorForLine = function (lineNumber) {
+//        errorsGutter.clearModeErrorForLine(lineNumber);
+//    }
 
-    this.addModeGutterWarning = function(from, to, message) {
-        errorsGutter.addModeWarning(from, to, message);
-    }
-
-    this.clearModeGutterErrorForLine = function(lineNumber) {
-        errorsGutter.clearModeErrorForLine(lineNumber);
-    }
-
     function ErrorGutters() {
 
         var currentErrors = [];
@@ -839,14 +839,14 @@
             return currentErrors;
         }
 
-        this.clearModeErrorForLine = function (lineNumber) {
-            for (var i = currentErrors.length - 1; i >= 0; i--) {
-                var error = currentErrors[i];
-                if (error.isModeError && error.from.line == lineNumber) {
-                    currentErrors.splice(i, 1);
-                }
-            }
-        }
+//        this.clearModeErrorForLine = function (lineNumber) {
+//            for (var i = currentErrors.length - 1; i >= 0; i--) {
+//                var error = currentErrors[i];
+//                if (error.isModeError && error.from.line == lineNumber) {
+//                    currentErrors.splice(i, 1);
+//                }
+//            }
+//        }
 
         this.clearForLine = function (lineNumber) {
             for (var i = currentErrors.length - 1; i >= 0; i--) {
@@ -871,32 +871,32 @@
             this.addMarker(from, to, "warning", message);
         }
 
-        this.addModeWarning = function (from, to, message) {
-            this.addModeMarker(from, to, "warning", message);
-        }
+//        this.addModeWarning = function (from, to, message) {
+//            this.addModeMarker(from, to, "warning", message);
+//        }
 
         this.addError = function (from, to, message) {
             this.addMarker(from, to, "error", message);
         }
 
-        this.addModeError = function (from, to, message) {
-            this.addModeMarker(from, to, "error", message);
-        }
+//        this.addModeError = function (from, to, message) {
+//            this.addModeMarker(from, to, "error", message);
+//        }
 
         this.addMarker = function (from, to, severity, message) {
             currentErrors.push({from: from, to: to,
                 severity: severity, message: message});
         }
 
-        this.addModeMarker = function (from, to, severity, message) {
-            var markerObj = {
-                from: from, to: to,
-                isModeError: true,
-                severity: severity,
-                message: message};
-            currentErrors.push(markerObj);
+//        this.addModeMarker = function (from, to, severity, message) {
+//            var markerObj = {
+//                from: from, to: to,
+//                isModeError: true,
+//                severity: severity,
+//                message: message};
+//            currentErrors.push(markerObj);
+//        }
-        }
+    }
-    }
 
     function markInvalidParameters(parameterGroupsInfos, invalidTokenClassName) {
 
@@ -911,18 +911,34 @@
                 var seenHeaderTokens = [];
                 for (var lineNum = pgi.startLine; lineNum <= pgi.endLine; lineNum++) {
                     var lineText = editor.getLineHandle(lineNum).text;
-                    if (lineText.substring(0, 1) == "|" && lineText.substring(0, 3) != "|--") {
+                    var lineTextTrimmed = lineText.replace(/\s+$/g, ''); // trim any trailing spaces
+                    if (lineTextTrimmed.length == 0) {
+                        // an empty line - do nothing
+                    } else if (lineTextTrimmed.substring(0, 3) == "|--") {
+                        // table comment line - do nothing
+                    } else if (lineTextTrimmed.substring(0, 1) != "|") {
+                        // illegal table line
+                        var startPos = {line: lineNum, ch: 0};
+                        var endPos = {line: lineNum, ch: 1};
+                        errorsGutter.addError(startPos, endPos, "Tabular parameter line must start with a '|'");
+                    } else if (lineTextTrimmed.substring(lineTextTrimmed.length - 1, lineTextTrimmed.length) != "|") {
+                        // illegal table line
+                        var startPos = {line: lineNum, ch: lineTextTrimmed.length - 1};
+                        var endPos = {line: lineNum, ch: lineTextTrimmed.length};
+                        errorsGutter.addError(startPos, endPos, "Tabular parameter line must end with a '|'");
+                    } else {
+                        // valid table line - process
                         if (firstTableLineFound == false) {
                             // this is table header line
                             firstTableLineFound = true;
                             // validate column names
                             var seenFieldNames = [];
                             var pos = 1; // we start from due to first pipe
-                            var tokens = lineText.split("|");
-                            for (var i = 1; i < tokens.length - 1; i++) {
+                            var tbHeaderTokens = lineTextTrimmed.split("|");
+                            for (var i = 1; i < tbHeaderTokens.length - 1; i++) {
                                 // we start from index 1 as the first token is the empty string before the first pipe
                                 // we do not validate last token which should be an empty string after the last pipe
-                                var token = tokens[i];
+                                var token = tbHeaderTokens[i];
                                 var leadingSpacesMatch = token.match(/^\s+/g);
                                 var numOfLeadingSpaces;
                                 if (leadingSpacesMatch != null && leadingSpacesMatch.length > 0) {
@@ -966,10 +982,16 @@
                                         }
                                     }
                                 } else {
+                                    if (token.length > 0) {
-                                    seenToken.start = pos;
-                                    seenToken.end = pos + token.length;
+                                        seenToken.start = pos;
+                                        seenToken.end = pos + token.length;
+                                    } else {
+                                        seenToken.start = pos - 1;
+                                        seenToken.end = pos + 1;
+                                    }
                                     seenToken.duplicate = false;
                                     seenToken.fieldNameValid = false;
+                                    seenToken.errorMsg = "Tabular field name cannot be empty";
                                 }
                                 seenHeaderTokens.push(seenToken);
                                 seenFieldNames.push(seenToken.fieldName);
@@ -987,13 +1009,31 @@
 //                                    editor.getDoc().markText(startPos, endPos, options);
                                 }
                             }
+                            // mark any missing mandatory fields
+                            for (var h = 0; h < tabularFieldInfos.length; h++) {
+                                var tfi = tabularFieldInfos[h];
+                                if (tfi.mandatory == true && indexOf(seenFieldNames, tfi.fieldName) == -1) {
+                                    var startPos = CodeMirror.Pos(lineNum, 0);
+                                    var endPos = CodeMirror.Pos(lineNum, 0);
+                                    var errorMsg = "Tabular parameter is missing a mandatory field '" + tfi.fieldName + "'";
+                                    errorsGutter.addError(startPos, endPos, errorMsg);
+                                }
+                            }
 
                         } else {
+
                             // this is table value line
-                            if (firstTableLineFound) {
-                                var seenValueTokens = [];
-                                var pos = 1; // we start from due to first pipe
+                            var seenValueTokens = [];
+                            var pos = 1; // we start from due to first pipe
-                                var tokens = lineText.split("|");
+                            var tokens = lineTextTrimmed.split("|");
+
+                            // check if number of values is the same as number of field names
+                            if (tokens.length - 2 != seenHeaderTokens.length) {
+                                var startPos = {line: lineNum, ch: 0};
+                                var endPos = {line: lineNum, ch: lineText.length};
+                                var errorMsg = "Number of field values doesn't equal to the number of field names";
+                                errorsGutter.addError(startPos, endPos, errorMsg);
+                            } else {
                                 for (var i = 1; i < tokens.length - 1; i++) {
                                     var token = tokens[i];
                                     var trimmedToken = token.trim();
@@ -1019,25 +1059,58 @@
                                     if (headerToken.fieldNameValid) {
                                         var lookingAtFieldName = headerToken.fieldName;
                                         // do the validation on value if allowedValues is present
-                                        var tabularFieldInfo = null;
+                                        var tfi = null;
                                         for (var j = 0; j < tabularFieldInfos.length; j++) {
                                             var tfi = tabularFieldInfos[j];
                                             if (tfi.fieldName == lookingAtFieldName) {
-                                                tabularFieldInfo = tfi;
+                                                tfi = tfi;
                                                 break;
                                             }
                                         }
-                                        if (tabularFieldInfo != null) {
-                                            // do the checking
-                                            var allowedValues = tabularFieldInfo.allowedValues;
+                                        if (tfi != null) {
+                                            if (seenValueToken.fieldValue.length == 0) {
+                                                // emty value
+                                                // check for mandatory value that is empty
+                                                if (tfi.mandatory == true) {
+                                                    seenValueToken.fieldValueValid = false;
+                                                    seenValueToken.errorMsg = "Tabular field '" + lookingAtFieldName + "' cannot be empty";
+                                                }
+                                            } else {
+                                                // non empty value
+                                                // do check for allowed values
+                                                var allowedValues = tfi.allowedValues;
-                                            if (allowedValues != null && allowedValues.length > 0) {
-                                                if (indexOf(allowedValues, seenValueToken.fieldValue) == -1) {
-                                                    // value is illegal
-                                                    seenValueToken.fieldValueValid = false;
-                                                    seenValueToken.errorMsg = "Value for tabular field '" + lookingAtFieldName + "' is invalid";
-                                                }
-                                            }
+                                                if (allowedValues != null && allowedValues.length > 0) {
+                                                    if (indexOf(allowedValues, seenValueToken.fieldValue) == -1) {
+                                                        // value is illegal
+                                                        seenValueToken.fieldValueValid = false;
+                                                        seenValueToken.errorMsg = "Value for tabular field '" + lookingAtFieldName + "' is invalid";
+                                                    }
+                                                }
+
+                                                if (seenValueToken.fieldValueValid == true
+                                                    && tfi.formatPattern != null
+                                                    && tfi.formatPattern.length > 0) {
+                                                    // check for format error
+                                                    var regExpPattern = new RegExp("^(" + tfi.formatPattern + ")$");
+                                                    var matchedResult = regExpPattern.exec(seenValueToken.fieldValue);
+                                                    if (matchedResult != null) {
+                                                        // value is valid
-                                        } else {
+                                                    } else {
+                                                        // value is invalid
+                                                        seenValueToken.fieldValueValid = false;
+                                                        var formatString;
+                                                        if (tfi.formatDisplayText != null && tfi.formatDisplayText.length > 0) {
+                                                            formatString = tfi.formatDisplayText;
+                                                        } else {
+                                                            formatString = tfi.formatPattern;
+                                                        }
+                                                        seenValueToken.errorMsg = "Value for tabular field '" + lookingAtFieldName
+                                                            + "' doesn't match expected format '" + formatString + "'";
+                                                    }
+                                                }
+
+                                            }
+                                        } else {
                                             // should not happen
                                             console.error("Could not find tabular fiend info for field - " + lookingAtFieldName + " in line - " + lineText);
                                         }
@@ -1047,7 +1120,6 @@
                                     pos += token.length;
                                     pos += 1; // for the pipe character
                                 }
-
                                 for (var r = 0; r < seenValueTokens.length; r++) {
                                     var svt = seenValueTokens[r];
                                     var startPos = {line: lineNum, ch: svt.start};
@@ -1057,21 +1129,62 @@
                                         errorsGutter.addError(startPos, endPos, svt.errorMsg);
                                     }
                                 }
-
-                            } else {
-                                // should not happen
-                                console.error("could not find table header line in table parameter in line - " + lineText);
                             }
 
                         }
                     }
                 }
             } else {
-                // it is not a tabular parameter
+                // simple parameter type
+                var listType = parameterInfo.listType;
+                if (listType == true) {
+                    // TODO - implement list type support
+                } else {
+                    var parameterValue = pgi.text.trim();
+
+                    if (parameterValue.length == 0) {
+                        // empty parameter
+                        var startPos = {line: pgi.startLine, ch: pgi.startLineCh - 1};
+                        var endPos = {line: pgi.endLine, ch: pgi.endLineCh + 1};
+                        errorsGutter.addError(startPos, endPos, "Missing parameter value");
+                    } else if (parameterInfo.allowedValues != null && parameterInfo.allowedValues.length > 0) {
+                        // check against allowed values
+                        var allowedValues = parameterInfo.allowedValues;
+                        if (indexOf(allowedValues, parameterValue) == -1) {
+                            // value is illegal
+                            var startPos = {line: pgi.startLine, ch: pgi.startLineCh};
+                            var endPos = {line: pgi.endLine, ch: pgi.endLineCh};
+                            errorsGutter.addError(startPos, endPos, "Parameter value is not valid");
-            }
+                        }
+                    } else {
+                        // pattern validation
+                        if (parameterInfo.formatPattern != null && parameterInfo.formatPattern.length > 0) {
+                            var regExpPattern = new RegExp("^(" + parameterInfo.formatPattern + ")$");
+                            var matchedResult = regExpPattern.exec(parameterValue);
+                            if (matchedResult != null) {
+                                // value is valid
+                            } else {
+                                // value is invalid
+                                var startPos = {line: pgi.startLine, ch: pgi.startLineCh};
+                                var endPos = {line: pgi.endLine, ch: pgi.endLineCh};
+                                // highlight the error
+                                var formatString;
+                                if (parameterInfo.formatDisplayText != null && parameterInfo.formatDisplayText.length > 0) {
+                                    formatString = parameterInfo.formatDisplayText;
+                                } else {
+                                    formatString = parameterInfo.formatPattern;
-        }
+                                }
+                                var errorMsg = "Parameter value doesn't match expected format '" + formatString + "'";
+                                errorsGutter.addError(startPos, endPos, errorMsg);
-    }
+                            }
+                        }
+                    }
+                }
 
+            }
+        }
+    }
+
     function EditorUtils() {
 
         this.lineStartsWithStepKeyword = function (lineNumber) {
@@ -1081,7 +1194,7 @@
                 return false;
             } else {
                 var lineText = lineHandle.text;
-                var regExpPattern = new RegExp("^(Given|When|Then|And)\\s");
+                var regExpPattern = /^(Given|When|Then|And)\s/;
                 var matchedResult = regExpPattern.exec(lineText);
                 if (matchedResult != null) {
                     return true;
@@ -1096,7 +1209,7 @@
             var lineHandle = editor.getLineHandle(lineNumber);
             var lineText = lineHandle.text;
 
-            var regExpPattern = new RegExp("^(And)\\s+");
+            var regExpPattern = /^(And)\s+/;
             var matchedResult = regExpPattern.exec(lineText);
             if (matchedResult != null) {
                 return true;
@@ -1289,7 +1402,7 @@
 
 
             // extract step body i.e. without the starting keyword
-            var regExpPattern = new RegExp("(^(Given|When|Then|And)\\s+)([\\s\\S]*)");
+            var regExpPattern = /(^(Given|When|Then|And)\s+)([\s\S]*)/;
             var matchedResult = regExpPattern.exec(step);
             var keyword;
             var stepBody;
@@ -1579,7 +1692,7 @@
                         // try to see if the step docs pattern matches step body
                         var regExpStr = stepDoc.groupedRegExpPattern;
                         // replace the (.*) with ([\s\S]*) for javascript version of dotall option
-                        var replacePattern = new RegExp("\\(\\.\\*\\)", "g");
+                        var replacePattern = /\(\.\*\)/g;
                         regExpStr = regExpStr.replace(replacePattern, "([\\s\\S]*)");
                         // add start and end chars to match the string exactly
                         regExpStr = "^" + regExpStr + "$";
Index: jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/mode/jbehave/jbehave.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/mode/jbehave/jbehave.js	(date 1411760883000)
+++ jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/mode/jbehave/jbehave.js	(revision )
@@ -15,13 +15,12 @@
             tableLineComment: "|--",
             blankLine: function (state) {
                 state.lineNumber++;
-                storyController.clearModeGutterErrorForLine(state.lineNumber);
+                storyController.errorsGutter.clearForLine(state.lineNumber);
             },
             startState: function () {
                 return {
 
                     lineNumber: -1,
-                    stepNumber: 0,
                     currentStepNumber: 0,
 
                     inDescription: false,
@@ -90,6 +89,10 @@
                     state.inExamplesBody = false;
                 }
 
+                var isStepLine = false;
+                var isCommentLine = false;
+                var foundErrors = [];
+
                 if (stream.sol()) {
 
                     state.lineNumber++;
@@ -97,18 +100,20 @@
                     state.inNarrativeField = false;
                     state.inLifecycleOutcome = false;
 
-                    storyController.clearModeGutterErrorForLine(state.lineNumber);
+//                    storyController.clearModeGutterErrorForLine(state.lineNumber);
                 }
 
                 state.lastTokenType = "";
 
                 // LINE COMMENT
-                if (stream.sol() && !state.inTable && (stream.match(/!--.*/) || stream.match(/\|--.*/))) {
+                if (stream.sol() && !state.inTable && stream.match(/!--.*/)) {
                     state.lastTokenType += " jb-story-comment";
+                    isCommentLine = true;
 
 //                    // TABLE COMMENT
                 } else if (stream.sol() && state.inTable && stream.match(/\|--.*/)) {
                     state.lastTokenType += " jb-story-table-comment";
+                    isCommentLine = true;
 
                     // META title
                 } else if (state.allowMeta && stream.sol() && stream.match(/(Meta):/)) {
@@ -308,7 +313,6 @@
 
                     state.inTable = false;
                     state.inStep = true;
-                    state.stepNumber++;
 //                    state.stepBody = "";
                     state.lastStepStartedAt = state.lineNumber;
 
@@ -344,7 +348,6 @@
 
                     state.inTable = false;
                     state.stepStartingKeyword = "When "; //TODO
-                    state.stepNumber++;
                     state.stepBody = "";
                     state.lastStepStartedAt = state.lineNumber;
 
@@ -381,8 +384,6 @@
 
                     state.inTable = false;
                     state.inStep = true;
-                    state.stepNumber++;
-//                    state.stepBody = "";
                     state.lastStepStartedAt = state.lineNumber;
 
                     state.inStepBody = false;
@@ -406,8 +407,6 @@
                     state.inStep = true;
                     state.inTable = false;
 
-                    state.stepNumber++;
-//                    state.stepBody = "";
                     state.lastStepStartedAt = state.lineNumber;
                     state.stepStartingKeyword = "And "; //TODO
 
@@ -495,8 +494,10 @@
                         var currentToken = stream.current();
                         var trimmedToken = currentToken.trim();
                         if (trimmedToken.length > 0) {
-                            var from = CodeMirror.Pos(state.lineNumber, stream.column());;
-                            var to = CodeMirror.Pos(state.lineNumber, stream.column() + currentToken.length);;
+                            var from = CodeMirror.Pos(state.lineNumber, stream.column());
+                            ;
+                            var to = CodeMirror.Pos(state.lineNumber, stream.column() + currentToken.length);
+                            ;
                             var msg = "Invalid text for given location";
                             storyController.addModeGutterError(from, to, msg);
                         } else {
Index: jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/atlassian-plugin.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/atlassian-plugin.xml	(date 1411760883000)
+++ jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/atlassian-plugin.xml	(revision )
@@ -3,8 +3,9 @@
 <atlassian-plugin key="com.jbehaveforjira.plugin" name="JBehave for Jira"
                   plugins-version="2">
     <plugin-info>
-        <description>${project.description}</description>
         <version>${project.version}</version>
+        <description>${project.description}</description>
+        <application-version min="6.0"/>
         <vendor name="Maryna Pristrom" url="http://www.jbehaveforjira.com"/>
         <param name="atlassian-licensing-enabled">true</param>
         <!--<param name="plugin-icon">images/marketing/pluginIcon.jpg</param>-->
Index: jbehave-for-jira/jbehave-for-jira-plugin/src/main/java/com/jbehaveforjira/plugin/dto/stepdoc/ParameterMetaInfo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-plugin/src/main/java/com/jbehaveforjira/plugin/dto/stepdoc/ParameterMetaInfo.java	(date 1411760883000)
+++ jbehave-for-jira/jbehave-for-jira-plugin/src/main/java/com/jbehaveforjira/plugin/dto/stepdoc/ParameterMetaInfo.java	(revision )
@@ -19,8 +19,10 @@
 
     public List<String> suggestedValues;
 
-    public String format;
+    public String formatPattern;
 
+    public String formatDisplayText;
+
     private List<TabularFieldInfo> tabularFieldInfos;
 
     public List<TabularFieldInfo> getTabularFieldInfos() {
@@ -71,11 +73,19 @@
         this.suggestedValues = suggestedValues;
     }
 
-    public String getFormat() {
-        return format;
+    public String getFormatPattern() {
+        return formatPattern;
     }
 
-    public void setFormat(String format) {
-        this.format = format;
+    public void setFormatPattern(String formatPattern) {
+        this.formatPattern = formatPattern;
+    }
+
+    public String getFormatDisplayText() {
+        return formatDisplayText;
+    }
+
+    public void setFormatDisplayText(String formatDisplayText) {
+        this.formatDisplayText = formatDisplayText;
     }
 }
Index: jbehave-for-jira/jbehave-for-jira-plugin/src/main/java/com/jbehaveforjira/plugin/dto/stepdoc/TabularFieldInfo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-plugin/src/main/java/com/jbehaveforjira/plugin/dto/stepdoc/TabularFieldInfo.java	(date 1411760883000)
+++ jbehave-for-jira/jbehave-for-jira-plugin/src/main/java/com/jbehaveforjira/plugin/dto/stepdoc/TabularFieldInfo.java	(revision )
@@ -17,8 +17,10 @@
 
     public List<String> suggestedValues;
 
-    public String format;
+    public String formatPattern;
 
+    public String formatDisplayText;;
+
     public String getFieldName() {
         return fieldName;
     }
@@ -51,11 +53,19 @@
         this.suggestedValues = suggestedValues;
     }
 
-    public String getFormat() {
-        return format;
+    public String getFormatPattern() {
+        return formatPattern;
     }
 
-    public void setFormat(String format) {
-        this.format = format;
+    public void setFormatPattern(String formatPattern) {
+        this.formatPattern = formatPattern;
+    }
+
+    public String getFormatDisplayText() {
+        return formatDisplayText;
+    }
+
+    public void setFormatDisplayText(String formatDisplayText) {
+        this.formatDisplayText = formatDisplayText;
     }
 }
Index: jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/hint/jbehave-hint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/hint/jbehave-hint.js	(date 1411760883000)
+++ jbehave-for-jira/jbehave-for-jira-plugin/src/main/resources/3rdparty/codemirror-4.3/addon/hint/jbehave-hint.js	(revision )
@@ -691,18 +691,18 @@
                             var pattern = stepDoc.pattern;
 
                             // replace any html tags, used in parameterized scenarios
-                            var regExpPattern = new RegExp("&", "g");
+                            var regExpPattern = /&/g;
                             pattern = pattern.replace(regExpPattern, "&amp;");
-                            regExpPattern = new RegExp("<", "g");
+                            regExpPattern = /</g;
                             pattern = pattern.replace(regExpPattern, "&lt;");
-                            regExpPattern = new RegExp(">", "g");
+                            regExpPattern = />/g;
                             pattern = pattern.replace(regExpPattern, "&gt;");
 
-                            regExpPattern = new RegExp("(\\$[^\\s]*)", "g");
+                            regExpPattern = /(\$[^\s]*)/g;
                             pattern = pattern.replace(regExpPattern, "<span class='cm-jb-story-step-body matched-step step-parameter'>$1</span>");
 
                             // replace any parameterized scenario arguments
-                            regExpPattern = new RegExp("(&lt;[^\\s]*&gt;)", "g");
+                            regExpPattern = /(&lt;[^\s]*&gt;)/g;
                             pattern = pattern.replace(regExpPattern, "<span class='cm-jb-story-step-body matched-step step-parameter'>$1</span>");
 
                             stepHint.markedPattern = pattern;
